# 测试方案文档

## 1. 测试策略概述

### 1.1 测试目标

1. **功能正确性**: 确保所有 API 和业务逻辑与原系统一致
2. **性能提升验证**: 验证性能优化目标达成
3. **稳定性保障**: 确保系统在高负载下稳定运行
4. **兼容性确认**: 确保与现有客户端（Node 客户端、浏览器客户端）完全兼容

### 1.2 测试金字塔

```
         /\
        /  \  E2E Tests (10%)
       /----\
      /      \  Integration Tests (30%)
     /--------\
    /          \  Unit Tests (60%)
   /____________\
```

**测试比例**:
- 单元测试: 60%
- 集成测试: 30%
- 端到端测试: 10%

### 1.3 测试环境

| 环境 | 用途 | 配置 |
|------|------|------|
| 开发环境 (Dev) | 日常开发测试 | 单机 Docker Compose |
| 测试环境 (Test) | 自动化测试 | 独立服务器 + CI/CD |
| 预发环境 (Staging) | 灰度发布前验证 | 生产同等配置 |
| 生产环境 (Prod) | 正式服务 | 高可用集群 |

## 2. 单元测试

### 2.1 测试框架

**Bun Test + Vitest 风格**
```typescript
// test/decorators/route.decorator.test.ts
import { describe, test, expect, beforeEach } from 'bun:test';
import { Controller, Get, Post } from '../../src/decorators';
import { ROUTE_METADATA } from '../../src/decorators/metadata';

describe('Route Decorators', () => {
  beforeEach(() => {
    ROUTE_METADATA.clear();
  });

  test('should register GET route', () => {
    @Controller('/api')
    class TestController {
      @Get('/users')
      getUsers() {}
    }

    const routes = ROUTE_METADATA.get(TestController);
    expect(routes).toBeDefined();
    expect(routes).toHaveLength(1);
    expect(routes[0]).toMatchObject({
      method: 'GET',
      path: '/users',
      handler: 'getUsers',
    });
  });

  test('should register multiple routes', () => {
    @Controller('/api')
    class TestController {
      @Get('/users')
      getUsers() {}

      @Post('/users')
      createUser() {}
    }

    const routes = ROUTE_METADATA.get(TestController);
    expect(routes).toHaveLength(2);
  });
});
```

### 2.2 装饰器测试

**参数装饰器测试**
```typescript
// test/decorators/param.decorator.test.ts
import { describe, test, expect } from 'bun:test';
import { Body, Query, Params } from '../../src/decorators';
import { PARAM_METADATA } from '../../src/decorators/metadata';

describe('Parameter Decorators', () => {
  test('should extract body parameter', () => {
    class TestController {
      createUser(@Body('name') name: string, @Body('age') age: number) {}
    }

    const params = PARAM_METADATA.get(TestController)?.get('createUser');
    expect(params).toBeDefined();
    expect(params).toHaveLength(2);
    expect(params[0]).toMatchObject({
      type: 'body',
      key: 'name',
      index: 0,
    });
    expect(params[1]).toMatchObject({
      type: 'body',
      key: 'age',
      index: 1,
    });
  });

  test('should extract query parameter', () => {
    class TestController {
      getUsers(@Query('page') page: number) {}
    }

    const params = PARAM_METADATA.get(TestController)?.get('getUsers');
    expect(params[0]).toMatchObject({
      type: 'query',
      key: 'page',
    });
  });
});
```

### 2.3 服务层测试

**LogBufferService 测试**
```typescript
// test/services/log-buffer.service.test.ts
import { describe, test, expect, beforeEach, mock } from 'bun:test';
import { LogBufferService } from '../../src/services/log-buffer.service';

describe('LogBufferService', () => {
  let logBuffer: LogBufferService;
  let mockCollection: any;

  beforeEach(() => {
    mockCollection = {
      insertMany: mock(() => Promise.resolve()),
    };
    logBuffer = new LogBufferService(mockCollection);
  });

  test('should buffer log entries', () => {
    logBuffer.add('logs', { message: 'test' });
    expect(logBuffer.getBufferSize()).toBe(1);
  });

  test('should flush when reaching max size', async () => {
    // 添加 1000 条记录（默认 maxSize）
    for (let i = 0; i < 1000; i++) {
      logBuffer.add('logs', { message: `test ${i}` });
    }

    // 应该触发自动 flush
    await new Promise(resolve => setTimeout(resolve, 100));
    expect(mockCollection.insertMany).toHaveBeenCalled();
    expect(logBuffer.getBufferSize()).toBe(0);
  });

  test('should flush on interval', async () => {
    logBuffer.add('logs', { message: 'test' });

    // 等待 1 秒（默认 flushInterval）
    await new Promise(resolve => setTimeout(resolve, 1100));

    expect(mockCollection.insertMany).toHaveBeenCalled();
  });

  test('should group by collection when flushing', async () => {
    logBuffer.add('logs', { message: 'log1' });
    logBuffer.add('errors', { message: 'error1' });
    logBuffer.add('logs', { message: 'log2' });

    await logBuffer.flush();

    expect(mockCollection.insertMany).toHaveBeenCalledTimes(2);
  });
});
```

**Worker Pool 测试**
```typescript
// test/workers/worker-pool.test.ts
import { describe, test, expect, beforeEach, afterEach } from 'bun:test';
import { WorkerPool } from '../../src/workers/worker-pool';

describe('WorkerPool', () => {
  let pool: WorkerPool;

  beforeEach(() => {
    pool = new WorkerPool({
      workerScript: './src/workers/parse.worker.ts',
      poolSize: 4,
    });
  });

  afterEach(async () => {
    await pool.destroy();
  });

  test('should dispatch task to worker', async () => {
    const result = await pool.dispatch({
      type: 'parse',
      data: { mac: 'test', pid: 1, contents: [] },
    });

    expect(result).toBeDefined();
  });

  test('should handle multiple concurrent tasks', async () => {
    const tasks = Array.from({ length: 10 }, (_, i) =>
      pool.dispatch({
        type: 'parse',
        data: { mac: `test${i}`, pid: i, contents: [] },
      })
    );

    const results = await Promise.all(tasks);
    expect(results).toHaveLength(10);
  });

  test('should queue tasks when all workers busy', async () => {
    // 发送 20 个任务（pool size 为 4）
    const tasks = Array.from({ length: 20 }, (_, i) =>
      pool.dispatch({
        type: 'parse',
        data: { mac: `test${i}`, pid: i, contents: [] },
      })
    );

    const results = await Promise.all(tasks);
    expect(results).toHaveLength(20);
  });

  test('should timeout tasks that take too long', async () => {
    const slowTask = pool.dispatch({
      type: 'parse',
      data: { mac: 'slow', pid: 1, contents: [] },
      timeout: 100, // 100ms 超时
    });

    await expect(slowTask).rejects.toThrow('Task timeout');
  });
});
```

### 2.4 控制器测试

**NodeController 测试**
```typescript
// test/controllers/node.controller.test.ts
import { describe, test, expect, beforeEach, mock } from 'bun:test';
import { NodeController } from '../../src/controllers/node.controller';

describe('NodeController', () => {
  let controller: NodeController;
  let mockServices: any;

  beforeEach(() => {
    mockServices = {
      terminalService: {
        setLastRecordDevs: mock(() => Promise.resolve()),
        getTerminal: mock(() => Promise.resolve({ mountDevs: [{ protocol: 'test' }] })),
      },
      queryDataService: {
        processAsync: mock(() => Promise.resolve()),
      },
      parseSet: new Set(),
    };

    controller = new NodeController(mockServices);
  });

  test('should handle queryData request', async () => {
    const data = {
      mac: '123456',
      pid: 1,
      protocol: 'test',
      contents: [],
      timeStamp: Date.now(),
    };

    const result = await controller.queryData(data);

    expect(result).toEqual({ status: 'ok' });
    expect(mockServices.terminalService.setLastRecordDevs).toHaveBeenCalledWith('123456', 1);
    expect(mockServices.queryDataService.processAsync).toHaveBeenCalled();
  });

  test('should skip duplicate requests', async () => {
    const data = {
      mac: '123456',
      pid: 1,
      protocol: 'test',
      contents: [],
      timeStamp: Date.now(),
    };

    // 第一次请求
    await controller.queryData(data);

    // 第二次请求（重复）
    const result = await controller.queryData(data);

    expect(result).toEqual({ status: 'skip' });
    expect(mockServices.queryDataService.processAsync).toHaveBeenCalledTimes(1);
  });

  test('should handle Pesiv card protocol variant', async () => {
    const data = {
      mac: '123456',
      pid: 1,
      protocol: 'Pesiv卡',
      contents: [],
      timeStamp: Date.now(),
    };

    await controller.queryData(data);

    expect(mockServices.terminalService.getTerminal).toHaveBeenCalledWith('123456');
  });
});
```

### 2.5 工具函数测试

```typescript
// test/utils/protocol.test.ts
import { describe, test, expect } from 'bun:test';
import { calculateCRC16, parseInstructionBuffer } from '../../src/utils/protocol';

describe('Protocol Utils', () => {
  test('should calculate CRC16 correctly', () => {
    const buffer = Buffer.from([0x01, 0x03, 0x00, 0x00, 0x00, 0x02]);
    const crc = calculateCRC16(buffer);
    expect(crc).toBe(0xC40B);
  });

  test('should parse instruction buffer', () => {
    const buffer = Buffer.from([0x01, 0x03, 0x04, 0x00, 0x01, 0x00, 0x02, 0x84, 0x39]);
    const result = parseInstructionBuffer(buffer, {
      protocol: 'Modbus RTU',
      registers: [{ address: 0, length: 2, type: 'uint16' }],
    });

    expect(result).toEqual({
      address: 1,
      function: 3,
      data: [1, 2],
    });
  });
});
```

### 2.6 覆盖率目标

**覆盖率要求**:
- 语句覆盖率 (Statement Coverage): ≥ 80%
- 分支覆盖率 (Branch Coverage): ≥ 75%
- 函数覆盖率 (Function Coverage): ≥ 85%
- 行覆盖率 (Line Coverage): ≥ 80%

**运行覆盖率测试**:
```bash
# 运行测试并生成覆盖率报告
bun test --coverage

# 查看覆盖率报告
open coverage/index.html
```

## 3. 集成测试

### 3.1 API 集成测试

**Fastify 应用测试**
```typescript
// test/integration/api.test.ts
import { describe, test, expect, beforeAll, afterAll } from 'bun:test';
import { build } from '../../src/app';
import { MongoMemoryServer } from 'mongodb-memory-server';

describe('API Integration Tests', () => {
  let app: any;
  let mongoServer: MongoMemoryServer;

  beforeAll(async () => {
    // 启动内存 MongoDB
    mongoServer = await MongoMemoryServer.create();
    const mongoUri = mongoServer.getUri();

    // 构建应用
    app = await build({
      logger: false,
      mongodb: { uri: mongoUri },
    });
  });

  afterAll(async () => {
    await app.close();
    await mongoServer.stop();
  });

  test('GET /health should return ok', async () => {
    const response = await app.inject({
      method: 'GET',
      url: '/health',
    });

    expect(response.statusCode).toBe(200);
    expect(response.json()).toMatchObject({
      status: 'ok',
    });
  });

  test('POST /api/node/queryData should return ok', async () => {
    const response = await app.inject({
      method: 'POST',
      url: '/api/node/queryData',
      payload: {
        data: {
          mac: '123456',
          pid: 1,
          protocol: 'test',
          contents: [],
          timeStamp: Date.now(),
        },
      },
    });

    expect(response.statusCode).toBe(200);
    expect(response.json()).toMatchObject({
      status: 'ok',
    });
  });

  test('should handle authentication', async () => {
    // 未授权请求
    const response1 = await app.inject({
      method: 'GET',
      url: '/api/user/info',
    });
    expect(response1.statusCode).toBe(401);

    // 授权请求
    const response2 = await app.inject({
      method: 'GET',
      url: '/api/user/info',
      headers: {
        Authorization: 'Bearer valid_token',
      },
    });
    expect(response2.statusCode).toBe(200);
  });
});
```

### 3.2 数据库集成测试

**MongoDB 集成测试**
```typescript
// test/integration/database.test.ts
import { describe, test, expect, beforeAll, afterAll } from 'bun:test';
import { MongoClient } from 'mongodb';
import { DataService } from '../../src/services/data.service';

describe('Database Integration Tests', () => {
  let client: MongoClient;
  let dataService: DataService;

  beforeAll(async () => {
    // 连接测试数据库
    client = new MongoClient(process.env.TEST_MONGODB_URI);
    await client.connect();
    dataService = new DataService(client);
  });

  afterAll(async () => {
    await client.close();
  });

  test('should save terminal result', async () => {
    const result = await dataService.updateTerminalResultSingle(
      '123456',
      1,
      {
        result: [{ name: 'temp', value: 25 }],
        timeStamp: Date.now(),
      }
    );

    expect(result).toBeDefined();
  });

  test('should query terminal results with pagination', async () => {
    // 插入测试数据
    const testData = Array.from({ length: 50 }, (_, i) => ({
      mac: '123456',
      pid: 1,
      result: [{ name: 'temp', value: i }],
      timeStamp: Date.now() + i * 1000,
    }));

    await dataService.resultModel.insertMany(testData);

    // 分页查询
    const page1 = await dataService.getTerminalResults('123456', 1, { skip: 0, take: 20 });
    expect(page1.data).toHaveLength(20);
    expect(page1.total).toBe(50);

    const page2 = await dataService.getTerminalResults('123456', 1, { skip: 20, take: 20 });
    expect(page2.data).toHaveLength(20);
  });
});
```

### 3.3 Socket.IO 集成测试

```typescript
// test/integration/socket.test.ts
import { describe, test, expect, beforeAll, afterAll } from 'bun:test';
import { io, Socket } from 'socket.io-client';
import { build } from '../../src/app';

describe('Socket.IO Integration Tests', () => {
  let app: any;
  let clientSocket: Socket;

  beforeAll(async () => {
    app = await build({ logger: false });
    await app.listen({ port: 0 }); // 随机端口

    const address = app.server.address();
    const port = typeof address === 'string' ? address : address?.port;

    clientSocket = io(`http://localhost:${port}/node`, {
      auth: { token: 'test_token' },
    });

    await new Promise(resolve => {
      clientSocket.on('connect', resolve);
    });
  });

  afterAll(async () => {
    clientSocket.close();
    await app.close();
  });

  test('should register node client', async () => {
    const response = await new Promise((resolve) => {
      clientSocket.emit('RegisterNode', { name: 'test-node', ip: '127.0.0.1' }, resolve);
    });

    expect(response).toMatchObject({
      status: 'ok',
    });
  });

  test('should receive query instruction', async () => {
    const instruction = await new Promise((resolve) => {
      clientSocket.on('InstructQuery', resolve);

      // 触发查询
      // (需要模拟查询循环)
    });

    expect(instruction).toBeDefined();
  });

  test('should handle disconnect', async () => {
    clientSocket.disconnect();

    await new Promise(resolve => setTimeout(resolve, 100));

    // 验证节点已从在线列表移除
    // (需要查询节点服务)
  });
});
```

### 3.4 Worker 集成测试

```typescript
// test/integration/worker.test.ts
import { describe, test, expect, beforeAll, afterAll } from 'bun:test';
import { WorkerPool } from '../../src/workers/worker-pool';
import { ProtocolService } from '../../src/services/protocol.service';

describe('Worker Integration Tests', () => {
  let workerPool: WorkerPool;
  let protocolService: ProtocolService;

  beforeAll(async () => {
    workerPool = new WorkerPool({
      workerScript: './src/workers/parse.worker.ts',
      poolSize: 4,
    });
    protocolService = new ProtocolService();
  });

  afterAll(async () => {
    await workerPool.destroy();
  });

  test('should parse real device data', async () => {
    // 获取真实协议
    const protocol = await protocolService.getProtocol('Modbus RTU');

    // 模拟真实设备数据
    const data = {
      mac: '123456',
      pid: 1,
      protocol: 'Modbus RTU',
      contents: [
        {
          content: 'temperature',
          buffer: { data: Buffer.from([0x01, 0x03, 0x04, 0x00, 0x19, 0x00, 0x00]) },
        },
      ],
      timeStamp: Date.now(),
    };

    // 通过 Worker 解析
    const result = await workerPool.dispatch({
      type: 'parse',
      data,
      protocol,
    });

    expect(result).toBeDefined();
    expect(result.length).toBeGreaterThan(0);
    expect(result[0]).toHaveProperty('name');
    expect(result[0]).toHaveProperty('value');
  });

  test('should handle parsing errors gracefully', async () => {
    const invalidData = {
      mac: '123456',
      pid: 1,
      protocol: 'unknown',
      contents: [],
      timeStamp: Date.now(),
    };

    await expect(
      workerPool.dispatch({
        type: 'parse',
        data: invalidData,
      })
    ).rejects.toThrow();
  });
});
```

## 4. 性能测试

### 4.1 K6 负载测试

**基础负载测试**
```javascript
// test/performance/load-test.js
import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate } from 'k6/metrics';

const errorRate = new Rate('errors');

export const options = {
  stages: [
    { duration: '30s', target: 100 },   // 爬坡到 100 并发
    { duration: '1m', target: 100 },    // 保持 100 并发
    { duration: '30s', target: 500 },   // 爬坡到 500 并发
    { duration: '2m', target: 500 },    // 保持 500 并发
    { duration: '30s', target: 1000 },  // 爬坡到 1000 并发
    { duration: '2m', target: 1000 },   // 保持 1000 并发
    { duration: '30s', target: 0 },     // 降到 0
  ],
  thresholds: {
    http_req_duration: ['p(95)<10', 'p(99)<20'],  // 95% < 10ms, 99% < 20ms
    http_req_failed: ['rate<0.01'],                // 错误率 < 1%
    errors: ['rate<0.01'],
  },
};

export default function () {
  // queryData API 测试
  const payload = JSON.stringify({
    data: {
      mac: `${__VU}-${__ITER}`,  // 使用虚拟用户 ID 和迭代次数作为唯一标识
      pid: 1,
      protocol: 'Modbus RTU',
      contents: [
        {
          content: 'temperature',
          buffer: { data: [1, 3, 4, 0, 25, 0, 0] },
        },
      ],
      timeStamp: Date.now(),
      useTime: 50,
      useBytes: 100,
      Interval: 1000,
    },
  });

  const params = {
    headers: {
      'Content-Type': 'application/json',
    },
  };

  const res = http.post('http://localhost:9000/api/node/queryData', payload, params);

  const success = check(res, {
    'status is 200': (r) => r.status === 200,
    'response time < 10ms': (r) => r.timings.duration < 10,
    'response is ok': (r) => r.json('status') === 'ok',
  });

  errorRate.add(!success);

  sleep(0.1); // 100ms 间隔
}
```

**运行性能测试**
```bash
# 安装 K6
brew install k6

# 运行负载测试
k6 run test/performance/load-test.js

# 输出结果到 InfluxDB（可选）
k6 run --out influxdb=http://localhost:8086/k6 test/performance/load-test.js

# 生成 HTML 报告
k6 run --out json=test-results.json test/performance/load-test.js
k6-html-reporter --input test-results.json --output test-report.html
```

### 4.2 压力测试

**压力测试脚本**
```javascript
// test/performance/stress-test.js
import http from 'k6/http';
import { check } from 'k6';

export const options = {
  stages: [
    { duration: '2m', target: 500 },
    { duration: '5m', target: 500 },
    { duration: '2m', target: 1000 },
    { duration: '5m', target: 1000 },
    { duration: '2m', target: 2000 },
    { duration: '5m', target: 2000 },
    { duration: '5m', target: 5000 },   // 极限压力
    { duration: '10m', target: 0 },
  ],
  thresholds: {
    http_req_duration: ['p(99)<50'],    // 99% < 50ms（压力测试下的阈值）
    http_req_failed: ['rate<0.05'],     // 错误率 < 5%
  },
};

export default function () {
  const res = http.post('http://localhost:9000/api/node/queryData',
    JSON.stringify({
      data: {
        mac: `${__VU}-${__ITER}`,
        pid: 1,
        protocol: 'test',
        contents: [],
        timeStamp: Date.now(),
      },
    }),
    {
      headers: { 'Content-Type': 'application/json' },
    }
  );

  check(res, {
    'status is 200 or 503': (r) => r.status === 200 || r.status === 503,
  });
}
```

### 4.3 持久性测试

**Soak Testing（浸泡测试）**
```javascript
// test/performance/soak-test.js
import http from 'k6/http';
import { check } from 'k6';

export const options = {
  stages: [
    { duration: '5m', target: 500 },    // 爬坡到 500
    { duration: '24h', target: 500 },   // 保持 500 并发 24 小时
    { duration: '5m', target: 0 },      // 降到 0
  ],
  thresholds: {
    http_req_duration: ['p(95)<15'],
    http_req_failed: ['rate<0.01'],
  },
};

export default function () {
  const res = http.post('http://localhost:9000/api/node/queryData',
    JSON.stringify({
      data: {
        mac: `${__VU}`,
        pid: Math.floor(Math.random() * 10),
        protocol: 'test',
        contents: [],
        timeStamp: Date.now(),
      },
    }),
    { headers: { 'Content-Type': 'application/json' } }
  );

  check(res, {
    'status is 200': (r) => r.status === 200,
    'no memory leaks': () => {
      // 检查响应头中的内存使用（如果应用提供）
      return true;
    },
  });
}
```

### 4.4 性能基准对比

**新旧版本对比测试**
```bash
#!/bin/bash
# test/performance/benchmark-compare.sh

echo "=== Performance Benchmark: Old vs New ==="

# 测试旧版本
echo "Testing OLD version..."
k6 run --out json=results-old.json test/performance/load-test.js

# 切换到新版本
docker-compose down
docker-compose -f docker-compose.new.yml up -d
sleep 30  # 等待服务启动

# 测试新版本
echo "Testing NEW version..."
k6 run --out json=results-new.json test/performance/load-test.js

# 生成对比报告
node test/performance/compare-results.js results-old.json results-new.json
```

**对比脚本**
```typescript
// test/performance/compare-results.ts
import fs from 'fs';

const oldResults = JSON.parse(fs.readFileSync(process.argv[2], 'utf-8'));
const newResults = JSON.parse(fs.readFileSync(process.argv[3], 'utf-8'));

function extractMetrics(results: any) {
  const metrics = results.metrics;
  return {
    p50: metrics.http_req_duration.values['p(50)'],
    p95: metrics.http_req_duration.values['p(95)'],
    p99: metrics.http_req_duration.values['p(99)'],
    rps: metrics.http_reqs.values.rate,
    errorRate: metrics.http_req_failed.values.rate,
  };
}

const old = extractMetrics(oldResults);
const newM = extractMetrics(newResults);

console.log('┌─────────────────┬──────────┬──────────┬──────────┐');
console.log('│ Metric          │ Old      │ New      │ Improve  │');
console.log('├─────────────────┼──────────┼──────────┼──────────┤');
console.log(`│ P50 (ms)        │ ${old.p50.toFixed(2).padStart(8)} │ ${newM.p50.toFixed(2).padStart(8)} │ ${((1 - newM.p50 / old.p50) * 100).toFixed(1)}%     │`);
console.log(`│ P95 (ms)        │ ${old.p95.toFixed(2).padStart(8)} │ ${newM.p95.toFixed(2).padStart(8)} │ ${((1 - newM.p95 / old.p95) * 100).toFixed(1)}%     │`);
console.log(`│ P99 (ms)        │ ${old.p99.toFixed(2).padStart(8)} │ ${newM.p99.toFixed(2).padStart(8)} │ ${((1 - newM.p99 / old.p99) * 100).toFixed(1)}%     │`);
console.log(`│ RPS             │ ${old.rps.toFixed(0).padStart(8)} │ ${newM.rps.toFixed(0).padStart(8)} │ ${((newM.rps / old.rps - 1) * 100).toFixed(1)}%     │`);
console.log(`│ Error Rate      │ ${(old.errorRate * 100).toFixed(3).padStart(8)} │ ${(newM.errorRate * 100).toFixed(3).padStart(8)} │ ${((1 - newM.errorRate / old.errorRate) * 100).toFixed(1)}%     │`);
console.log('└─────────────────┴──────────┴──────────┴──────────┘');
```

## 5. 端到端测试

### 5.1 Playwright E2E 测试

**浏览器客户端测试**
```typescript
// test/e2e/user-dashboard.spec.ts
import { test, expect } from '@playwright/test';

test.describe('User Dashboard E2E', () => {
  test.beforeEach(async ({ page }) => {
    // 登录
    await page.goto('http://localhost:3000/login');
    await page.fill('input[name="username"]', 'testuser');
    await page.fill('input[name="password"]', 'password');
    await page.click('button[type="submit"]');
    await page.waitForURL('**/dashboard');
  });

  test('should display terminal list', async ({ page }) => {
    await expect(page.locator('.terminal-list')).toBeVisible();
    await expect(page.locator('.terminal-item')).toHaveCount(5);
  });

  test('should receive real-time data updates', async ({ page }) => {
    const initialValue = await page.locator('.temp-value').textContent();

    // 等待 Socket.IO 更新
    await page.waitForTimeout(2000);

    const updatedValue = await page.locator('.temp-value').textContent();
    expect(updatedValue).not.toBe(initialValue);
  });

  test('should handle alarm notification', async ({ page }) => {
    // 监听 Socket.IO 事件
    const alarmPromise = page.waitForEvent('console', msg =>
      msg.text().includes('alarm')
    );

    // 触发告警（通过后端 API）
    await page.evaluate(() => {
      fetch('http://localhost:9000/test/trigger-alarm', {
        method: 'POST',
        body: JSON.stringify({ mac: '123456', pid: 1 }),
      });
    });

    // 验证告警通知
    await alarmPromise;
    await expect(page.locator('.alarm-notification')).toBeVisible();
  });
});
```

### 5.2 Node 客户端 E2E 测试

```typescript
// test/e2e/node-client.spec.ts
import { test, expect } from 'bun:test';
import { io, Socket } from 'socket.io-client';

test.describe('Node Client E2E', () => {
  let socket: Socket;

  test.beforeAll(() => {
    socket = io('http://localhost:9000/node', {
      auth: { token: 'test_token' },
    });

    return new Promise(resolve => {
      socket.on('connect', resolve);
    });
  });

  test.afterAll(() => {
    socket.close();
  });

  test('complete device query flow', async () => {
    // 1. 注册节点
    const registerResult = await new Promise(resolve => {
      socket.emit('RegisterNode', {
        name: 'test-node',
        ip: '127.0.0.1',
        port: 12345,
      }, resolve);
    });
    expect(registerResult).toMatchObject({ status: 'ok' });

    // 2. 接收查询指令
    const instruction = await new Promise(resolve => {
      socket.once('InstructQuery', resolve);
    });
    expect(instruction).toHaveProperty('mac');
    expect(instruction).toHaveProperty('instruction');

    // 3. 返回查询结果
    const resultResponse = await fetch('http://localhost:9000/api/node/queryData', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        data: {
          mac: instruction.mac,
          pid: instruction.pid,
          protocol: instruction.protocol,
          contents: [
            {
              content: 'test',
              buffer: { data: [1, 2, 3, 4] },
            },
          ],
          timeStamp: Date.now(),
        },
      }),
    });
    expect(resultResponse.ok).toBe(true);

    // 4. 等待数据处理完成
    await new Promise(resolve => setTimeout(resolve, 1000));

    // 5. 验证数据已保存
    const dataResponse = await fetch(
      `http://localhost:9000/api/terminal/${instruction.mac}/${instruction.pid}/latest`
    );
    const data = await dataResponse.json();
    expect(data).toHaveProperty('result');
  });
});
```

## 6. 兼容性测试

### 6.1 API 兼容性测试

**对比测试脚本**
```typescript
// test/compatibility/api-compatibility.test.ts
import { describe, test, expect } from 'bun:test';

describe('API Compatibility', () => {
  const oldAPI = 'http://localhost:9000';  // 旧版本
  const newAPI = 'http://localhost:9001';  // 新版本

  test('queryData API should return same format', async () => {
    const payload = {
      data: {
        mac: '123456',
        pid: 1,
        protocol: 'test',
        contents: [],
        timeStamp: Date.now(),
      },
    };

    const [oldRes, newRes] = await Promise.all([
      fetch(`${oldAPI}/api/node/queryData`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      }),
      fetch(`${newAPI}/api/node/queryData`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      }),
    ]);

    const oldData = await oldRes.json();
    const newData = await newRes.json();

    // 验证响应格式一致
    expect(Object.keys(oldData).sort()).toEqual(Object.keys(newData).sort());
  });

  test('pagination should work consistently', async () => {
    const [oldRes, newRes] = await Promise.all([
      fetch(`${oldAPI}/api/terminal/123456/1/results?page=1&limit=20`),
      fetch(`${newAPI}/api/terminal/123456/1/results?skip=0&take=20`),
    ]);

    const oldData = await oldRes.json();
    const newData = await newRes.json();

    // 新版本应该包含 total 字段
    expect(newData).toHaveProperty('total');
    expect(newData).toHaveProperty('data');
    expect(Array.isArray(newData.data)).toBe(true);
  });
});
```

### 6.2 Socket.IO 兼容性测试

```typescript
// test/compatibility/socket-compatibility.test.ts
import { describe, test, expect } from 'bun:test';
import { io } from 'socket.io-client';

describe('Socket.IO Compatibility', () => {
  test('old clients should connect to new server', async () => {
    const socket = io('http://localhost:9001/node', {
      auth: { token: 'test_token' },
      transports: ['websocket'], // 旧客户端使用的传输方式
    });

    const connected = await new Promise((resolve) => {
      socket.on('connect', () => resolve(true));
      socket.on('connect_error', () => resolve(false));
    });

    expect(connected).toBe(true);
    socket.close();
  });

  test('event format should be compatible', async () => {
    const socket = io('http://localhost:9001/node', {
      auth: { token: 'test_token' },
    });

    await new Promise(resolve => socket.on('connect', resolve));

    // 发送旧格式事件
    const response = await new Promise(resolve => {
      socket.emit('RegisterNode', {
        name: 'test-node',
        ip: '127.0.0.1',
      }, resolve);
    });

    expect(response).toHaveProperty('status');
    socket.close();
  });
});
```

## 7. 回归测试

### 7.1 自动化回归测试套件

```typescript
// test/regression/regression-suite.test.ts
import { describe, test } from 'bun:test';
import { runAllTests } from '../utils/test-runner';

describe('Regression Test Suite', () => {
  test('unit tests', async () => {
    await runAllTests('test/unit/**/*.test.ts');
  });

  test('integration tests', async () => {
    await runAllTests('test/integration/**/*.test.ts');
  });

  test('api compatibility tests', async () => {
    await runAllTests('test/compatibility/**/*.test.ts');
  });

  test('performance benchmarks', async () => {
    await runAllTests('test/performance/benchmark.test.ts');
  });
});
```

### 7.2 数据完整性测试

```typescript
// test/regression/data-integrity.test.ts
import { describe, test, expect } from 'bun:test';
import { MongoClient } from 'mongodb';

describe('Data Integrity Tests', () => {
  test('terminal results should be consistent', async () => {
    const oldDB = new MongoClient(process.env.OLD_MONGODB_URI);
    const newDB = new MongoClient(process.env.NEW_MONGODB_URI);

    await oldDB.connect();
    await newDB.connect();

    const mac = '123456';
    const pid = 1;

    // 查询两个数据库中的相同数据
    const oldData = await oldDB
      .db()
      .collection('uartTerminalResults')
      .findOne({ mac, pid });

    const newData = await newDB
      .db()
      .collection('uartTerminalResults')
      .findOne({ mac, pid });

    // 验证关键字段一致
    expect(newData?.result).toEqual(oldData?.result);
    expect(newData?.timeStamp).toEqual(oldData?.timeStamp);

    await oldDB.close();
    await newDB.close();
  });
});
```

## 8. 验收测试

### 8.1 验收标准

**功能验收**:
- [ ] 所有 API 端点正常工作
- [ ] Socket.IO 实时通信正常
- [ ] 设备查询和数据解析正常
- [ ] 告警检测和推送正常
- [ ] 用户认证和授权正常
- [ ] 数据存储和查询正常

**性能验收**:
- [ ] queryData API P95 延迟 < 10ms ✅ 目标: 5ms
- [ ] queryData API P99 延迟 < 20ms ✅ 目标: 10ms
- [ ] 吞吐量 > 8000 req/s ✅ 目标: 10000 req/s
- [ ] CPU 使用率 < 50% ✅ 目标: 40%
- [ ] 内存使用 < 500MB ✅ 目标: 400MB
- [ ] MongoDB 写入 < 100 ops/s ✅ 目标: 80 ops/s

**稳定性验收**:
- [ ] 24 小时持久性测试无内存泄漏
- [ ] 错误率 < 0.01% (99.99% 可用性)
- [ ] 自动恢复机制正常工作
- [ ] 日志记录完整无遗漏

**兼容性验收**:
- [ ] 现有 Node 客户端无需修改即可使用
- [ ] 现有浏览器客户端无需修改即可使用
- [ ] API 响应格式向后兼容
- [ ] Socket.IO 事件格式向后兼容

### 8.2 验收测试脚本

```bash
#!/bin/bash
# test/acceptance/run-acceptance.sh

set -e

echo "=== Running Acceptance Tests ==="

# 1. 功能测试
echo "1. Running functional tests..."
bun test test/integration/**/*.test.ts

# 2. 性能测试
echo "2. Running performance tests..."
k6 run test/performance/load-test.js

# 3. 兼容性测试
echo "3. Running compatibility tests..."
bun test test/compatibility/**/*.test.ts

# 4. 持久性测试
echo "4. Running soak test (24h)..."
k6 run test/performance/soak-test.js

# 5. 数据完整性测试
echo "5. Running data integrity tests..."
bun test test/regression/data-integrity.test.ts

# 6. E2E 测试
echo "6. Running E2E tests..."
playwright test test/e2e/**/*.spec.ts

echo "=== All Acceptance Tests Passed ✅ ==="
```

## 9. 测试环境配置

### 9.1 CI/CD 集成

**GitHub Actions 配置**
```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: 1.1.40

      - name: Install dependencies
        run: bun install

      - name: Run unit tests
        run: bun test test/unit

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage/coverage-final.json

  integration-tests:
    runs-on: ubuntu-latest
    services:
      mongodb:
        image: mongo:8.0
        ports:
          - 27017:27017
      redis:
        image: redis:7.4-alpine
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v3
      - uses: oven-sh/setup-bun@v1
      - run: bun install
      - run: bun test test/integration

  performance-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: grafana/setup-k6-action@v1
      - name: Run load test
        run: k6 run test/performance/load-test.js
      - name: Check thresholds
        run: |
          if [ $? -ne 0 ]; then
            echo "Performance thresholds not met!"
            exit 1
          fi
```

### 9.2 本地测试环境

**Docker Compose 测试环境**
```yaml
# docker-compose.test.yml
version: '3.8'

services:
  app-test:
    build:
      context: .
      dockerfile: Dockerfile.test
    environment:
      NODE_ENV: test
      MONGODB_URI: mongodb://mongo-test:27017/uart_test
      REDIS_HOST: redis-test
    depends_on:
      - mongo-test
      - redis-test
    ports:
      - "9001:9000"

  mongo-test:
    image: mongo:8.0
    ports:
      - "27018:27017"
    tmpfs:
      - /data/db  # 使用内存存储，测试更快

  redis-test:
    image: redis:7.4-alpine
    ports:
      - "6380:6379"
```

**启动测试环境**
```bash
# 启动测试环境
docker-compose -f docker-compose.test.yml up -d

# 运行测试
bun test

# 清理测试环境
docker-compose -f docker-compose.test.yml down -v
```

## 10. 测试报告

### 10.1 生成测试报告

```typescript
// test/utils/reporter.ts
import fs from 'fs';
import path from 'path';

export class TestReporter {
  private results: any[] = [];

  addResult(suite: string, test: string, status: string, duration: number) {
    this.results.push({ suite, test, status, duration, timestamp: Date.now() });
  }

  generateReport() {
    const html = `
<!DOCTYPE html>
<html>
<head>
  <title>Test Report</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .pass { color: green; }
    .fail { color: red; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
    th { background-color: #4CAF50; color: white; }
  </style>
</head>
<body>
  <h1>Test Report</h1>
  <p>Total: ${this.results.length}</p>
  <p>Passed: <span class="pass">${this.results.filter(r => r.status === 'pass').length}</span></p>
  <p>Failed: <span class="fail">${this.results.filter(r => r.status === 'fail').length}</span></p>

  <table>
    <tr>
      <th>Suite</th>
      <th>Test</th>
      <th>Status</th>
      <th>Duration (ms)</th>
    </tr>
    ${this.results.map(r => `
      <tr>
        <td>${r.suite}</td>
        <td>${r.test}</td>
        <td class="${r.status}">${r.status}</td>
        <td>${r.duration.toFixed(2)}</td>
      </tr>
    `).join('')}
  </table>
</body>
</html>
    `;

    const reportPath = path.join(process.cwd(), 'test-report.html');
    fs.writeFileSync(reportPath, html);
    console.log(`Test report generated: ${reportPath}`);
  }
}
```

### 10.2 测试度量指标

**关键指标**:
- 测试覆盖率: ≥ 80%
- 测试通过率: ≥ 99%
- 平均测试时间: < 5 分钟
- 关键路径测试: 100% 覆盖

---

**文档版本**: v1.0
**最后更新**: 2024-12-16
**维护者**: 开发团队
