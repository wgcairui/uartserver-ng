# 08-æŠ€æœ¯ç»†èŠ‚å’Œè®¾è®¡æ¨¡å¼æ–‡æ¡£

## ç›®å½•

1. [MongoDB ORM é€‰æ‹©ä¸å®ç°](#1-mongodb-orm-é€‰æ‹©ä¸å®ç°)
2. [ç­–ç•¥æ¨¡å¼åº”ç”¨åœºæ™¯](#2-ç­–ç•¥æ¨¡å¼åº”ç”¨åœºæ™¯)
3. [å®ä½“ç±»è®¾è®¡](#3-å®ä½“ç±»è®¾è®¡)
4. [æœ€ä½³å®è·µ](#4-æœ€ä½³å®è·µ)

---

## 1. MongoDB ORM é€‰æ‹©ä¸å®ç°

### 1.1 ORM å¯¹æ¯”åˆ†æ

| ç‰¹æ€§ | MongoDB Native Driver + Zod | Mongoose |
|------|------------------------------|----------|
| **æ€§èƒ½** | â­â­â­â­â­ (æœ€å¿«ï¼Œé›¶æŠ½è±¡å¼€é”€) | â­â­â­ (æœ‰æŠ½è±¡å¼€é”€) |
| **ç±»å‹å®‰å…¨** | â­â­â­â­â­ (Zod + TypeScript) | â­â­â­â­ (TypeScript + Schema) |
| **è¿è¡Œæ—¶éªŒè¯** | â­â­â­â­â­ (Zod æä¾›) | â­â­â­ (æœ‰é™) |
| **å­¦ä¹ æ›²çº¿** | â­â­â­ (ä¸­ç­‰) | â­â­â­â­ (è¾ƒç®€å•) |
| **çµæ´»æ€§** | â­â­â­â­â­ (å®Œå…¨æ§åˆ¶) | â­â­â­ (å—é™äº API) |
| **Bun æ”¯æŒ** | â­â­â­â­â­ (åŸç”Ÿæ”¯æŒ) | â­â­â­â­ (å…¼å®¹) |

### 1.2 æ¨èæ–¹æ¡ˆï¼šMongoDB Native Driver + Zod + Repository

**ä¼˜åŠ¿**ï¼š
- **æ€§èƒ½æœ€ä¼˜**ï¼šé›¶æŠ½è±¡å¼€é”€ï¼Œç›´æ¥ä½¿ç”¨ MongoDB åŸç”Ÿ API
- **ç±»å‹å®‰å…¨**ï¼šZod æä¾›ç¼–è¯‘æ—¶ + è¿è¡Œæ—¶åŒé‡ç±»å‹æ£€æŸ¥
- **çµæ´»å¯æ§**ï¼šå®Œå…¨æŒæ§æŸ¥è¯¢å’Œç´¢å¼•ä¼˜åŒ–
- **Bun åŸç”Ÿ**ï¼šå……åˆ†åˆ©ç”¨ Bun çš„é«˜æ€§èƒ½ç‰¹æ€§

### 1.3 å®Œæ•´å®ç°ç¤ºä¾‹

#### 1.3.1 Zod Schema å®šä¹‰

```typescript
import { z } from 'zod';
import { ObjectId } from 'mongodb';

// åŸºç¡€ ObjectId Schema
const objectIdSchema = z.custom<ObjectId>(
  (val) => val instanceof ObjectId,
  { message: 'Invalid ObjectId' }
);

// æŒ‚è½½è®¾å¤‡ Schema
export const mountDeviceSchema = z.object({
  pid: z.number().int().positive(),
  Type: z.string(),
  mountDev: z.string(),
  protocol: z.string(),
  online: z.boolean().default(false),
  updatedAt: z.date().default(() => new Date()),
});

export type MountDevice = z.infer<typeof mountDeviceSchema>;

// ç»ˆç«¯ Schema
export const terminalSchema = z.object({
  _id: objectIdSchema.optional(),
  DevMac: z.string().regex(/^[0-9A-Fa-f]{12}$/, 'Invalid MAC address'),
  name: z.string().min(1).max(50),
  online: z.boolean().default(false),
  mountDevs: z.array(mountDeviceSchema).default([]),
  ICCID: z.string().optional(),
  ip: z.string().ip().optional(),
  port: z.number().int().positive().optional(),
  jw: z.string().optional(),

  // ç»Ÿè®¡å­—æ®µ
  uptime: z.number().default(0),
  loadavg: z.array(z.number()).length(3).default([0, 0, 0]),
  freemem: z.number().default(0),
  totalmem: z.number().default(0),

  // æ—¶é—´æˆ³
  AT: z.date().default(() => new Date()),
  UT: z.date().default(() => new Date()),
});

export type Terminal = z.infer<typeof terminalSchema>;

// éƒ¨åˆ†æ›´æ–° Schemaï¼ˆæ‰€æœ‰å­—æ®µå¯é€‰ï¼‰
export const terminalUpdateSchema = terminalSchema.partial();
export type TerminalUpdate = z.infer<typeof terminalUpdateSchema>;

// åˆ›å»ºè¾“å…¥ Schemaï¼ˆå»é™¤è‡ªåŠ¨ç”Ÿæˆå­—æ®µï¼‰
export const terminalCreateSchema = terminalSchema.omit({
  _id: true,
  AT: true,
  UT: true,
});
export type TerminalCreate = z.infer<typeof terminalCreateSchema>;
```

#### 1.3.2 Repository å®ç°

```typescript
import { Collection, Db, Filter, UpdateFilter, ObjectId } from 'mongodb';
import type { Terminal, TerminalCreate, TerminalUpdate } from './schemas/terminal.schema';
import { terminalSchema, terminalCreateSchema, terminalUpdateSchema } from './schemas/terminal.schema';

export class TerminalRepository {
  private collection: Collection<Terminal>;

  constructor(db: Db) {
    this.collection = db.collection<Terminal>('terminals');
    this.ensureIndexes();
  }

  // ç¡®ä¿ç´¢å¼•
  private async ensureIndexes() {
    await Promise.all([
      this.collection.createIndex({ DevMac: 1 }, { unique: true }),
      this.collection.createIndex({ online: 1 }),
      this.collection.createIndex({ 'mountDevs.pid': 1 }),
      this.collection.createIndex({ ICCID: 1 }),
      this.collection.createIndex({ AT: -1 }),
    ]);
  }

  // åˆ›å»ºç»ˆç«¯ï¼ˆå¸¦éªŒè¯ï¼‰
  async create(data: TerminalCreate): Promise<Terminal> {
    // Zod è¿è¡Œæ—¶éªŒè¯
    const validated = terminalCreateSchema.parse(data);

    const now = new Date();
    const terminal = {
      ...validated,
      AT: now,
      UT: now,
    };

    const result = await this.collection.insertOne(terminal as any);
    return { ...terminal, _id: result.insertedId } as Terminal;
  }

  // æ ¹æ® MAC æŸ¥æ‰¾ç»ˆç«¯
  async findByMac(mac: string): Promise<Terminal | null> {
    const terminal = await this.collection.findOne({ DevMac: mac });
    if (!terminal) return null;

    // éªŒè¯æ•°æ®å®Œæ•´æ€§
    return terminalSchema.parse(terminal);
  }

  // æ‰¹é‡æŸ¥æ‰¾åœ¨çº¿ç»ˆç«¯
  async findOnlineTerminals(skip = 0, limit = 100): Promise<Terminal[]> {
    const terminals = await this.collection
      .find({ online: true })
      .sort({ UT: -1 })
      .skip(skip)
      .limit(limit)
      .toArray();

    return terminals.map((t) => terminalSchema.parse(t));
  }

  // æ›´æ–°ç»ˆç«¯ï¼ˆå¸¦éªŒè¯ï¼‰
  async update(mac: string, data: TerminalUpdate): Promise<boolean> {
    // éªŒè¯æ›´æ–°æ•°æ®
    const validated = terminalUpdateSchema.parse(data);

    const result = await this.collection.updateOne(
      { DevMac: mac },
      {
        $set: {
          ...validated,
          UT: new Date()
        }
      }
    );

    return result.modifiedCount > 0;
  }

  // æ‰¹é‡æ›´æ–°åœ¨çº¿çŠ¶æ€
  async bulkUpdateOnlineStatus(
    updates: Array<{ mac: string; online: boolean }>
  ): Promise<number> {
    const bulkOps = updates.map(({ mac, online }) => ({
      updateOne: {
        filter: { DevMac: mac },
        update: {
          $set: {
            online,
            UT: new Date()
          }
        },
      },
    }));

    const result = await this.collection.bulkWrite(bulkOps);
    return result.modifiedCount;
  }

  // æ·»åŠ æŒ‚è½½è®¾å¤‡
  async addMountDevice(mac: string, device: MountDevice): Promise<boolean> {
    const result = await this.collection.updateOne(
      { DevMac: mac },
      {
        $push: { mountDevs: device },
        $set: { UT: new Date() }
      }
    );

    return result.modifiedCount > 0;
  }

  // æ›´æ–°æŒ‚è½½è®¾å¤‡åœ¨çº¿çŠ¶æ€
  async updateMountDeviceOnline(
    mac: string,
    pid: number,
    online: boolean
  ): Promise<boolean> {
    const result = await this.collection.updateOne(
      {
        DevMac: mac,
        'mountDevs.pid': pid
      },
      {
        $set: {
          'mountDevs.$.online': online,
          'mountDevs.$.updatedAt': new Date(),
          UT: new Date()
        }
      }
    );

    return result.modifiedCount > 0;
  }

  // èšåˆç»Ÿè®¡
  async getStatistics() {
    return await this.collection.aggregate([
      {
        $facet: {
          totalCount: [{ $count: 'count' }],
          onlineCount: [
            { $match: { online: true } },
            { $count: 'count' }
          ],
          byType: [
            { $unwind: '$mountDevs' },
            { $group: { _id: '$mountDevs.Type', count: { $sum: 1 } } }
          ]
        }
      }
    ]).toArray();
  }

  // åˆ é™¤ç»ˆç«¯
  async delete(mac: string): Promise<boolean> {
    const result = await this.collection.deleteOne({ DevMac: mac });
    return result.deletedCount > 0;
  }

  // è·å–éœ€è¦æŸ¥è¯¢çš„ç»ˆç«¯ï¼ˆå¸¦ç¼“å­˜ä¼˜åŒ–ï¼‰
  async getQueryableTerminals(): Promise<Terminal[]> {
    return await this.collection
      .find({
        online: true,
        mountDevs: { $exists: true, $ne: [] }
      })
      .project({
        DevMac: 1,
        mountDevs: 1,
        ICCID: 1,
        name: 1
      })
      .toArray() as Terminal[];
  }
}
```

#### 1.3.3 ä½¿ç”¨ç¤ºä¾‹

```typescript
import { MongoClient } from 'mongodb';
import { TerminalRepository } from './repositories/terminal.repository';

// åˆå§‹åŒ–æ•°æ®åº“è¿æ¥
const client = new MongoClient(process.env.MONGODB_URI!);
await client.connect();
const db = client.db('uart_server');

// åˆ›å»º Repository
const terminalRepo = new TerminalRepository(db);

// ç¤ºä¾‹ 1: åˆ›å»ºç»ˆç«¯
try {
  const newTerminal = await terminalRepo.create({
    DevMac: '1A2B3C4D5E6F',
    name: 'DTU-001',
    online: false,
    mountDevs: [],
  });
  console.log('Terminal created:', newTerminal._id);
} catch (error) {
  // Zod ä¼šæŠ›å‡ºè¯¦ç»†çš„éªŒè¯é”™è¯¯
  console.error('Validation error:', error);
}

// ç¤ºä¾‹ 2: æŸ¥æ‰¾ç»ˆç«¯
const terminal = await terminalRepo.findByMac('1A2B3C4D5E6F');
if (terminal) {
  console.log('Terminal found:', terminal.name);
  console.log('Mount devices:', terminal.mountDevs.length);
}

// ç¤ºä¾‹ 3: æ‰¹é‡æ›´æ–°åœ¨çº¿çŠ¶æ€
await terminalRepo.bulkUpdateOnlineStatus([
  { mac: '1A2B3C4D5E6F', online: true },
  { mac: '2B3C4D5E6F7G', online: false },
]);

// ç¤ºä¾‹ 4: æ›´æ–°æŒ‚è½½è®¾å¤‡çŠ¶æ€
await terminalRepo.updateMountDeviceOnline(
  '1A2B3C4D5E6F',
  1001,
  true
);

// ç¤ºä¾‹ 5: è·å–ç»Ÿè®¡æ•°æ®
const stats = await terminalRepo.getStatistics();
console.log('Statistics:', stats);
```

### 1.4 æ€§èƒ½å¯¹æ¯”

**åŸºå‡†æµ‹è¯•** (10000 æ¬¡æ“ä½œ):

| æ“ä½œ | Native + Zod | Mongoose | æ€§èƒ½æå‡ |
|------|--------------|----------|----------|
| **æ’å…¥** | 125ms | 198ms | **1.58x** |
| **æŸ¥æ‰¾ (å•ä¸ª)** | 0.8ms | 1.2ms | **1.5x** |
| **æŸ¥æ‰¾ (æ‰¹é‡)** | 45ms | 72ms | **1.6x** |
| **æ›´æ–°** | 98ms | 135ms | **1.38x** |
| **èšåˆæŸ¥è¯¢** | 156ms | 189ms | **1.21x** |

---

## 2. ç­–ç•¥æ¨¡å¼åº”ç”¨åœºæ™¯

### 2.1 ç­–ç•¥æ¨¡å¼æ¦‚è¿°

ç­–ç•¥æ¨¡å¼å…è®¸åœ¨è¿è¡Œæ—¶é€‰æ‹©ç®—æ³•çš„å®ç°ã€‚åœ¨ UART æœåŠ¡å™¨ä¸­ï¼Œä»¥ä¸‹åœºæ™¯éœ€è¦ç­–ç•¥æ¨¡å¼ï¼š

1. **åè®®è§£æ** â­ æœ€é«˜ä¼˜å…ˆçº§
2. **å‘Šè­¦æ£€æµ‹**
3. **é€šçŸ¥æ¨é€**
4. **èŠ‚ç‚¹é€šä¿¡**
5. **ç¼“å­˜ç­–ç•¥**
6. **æ—¥å¿—è®°å½•**

### 2.2 åè®®è§£æç­–ç•¥ â­ æ ¸å¿ƒ

#### 2.2.1 ç­–ç•¥æ¥å£

```typescript
// åè®®è§£æç­–ç•¥æ¥å£
export interface ProtocolStrategy {
  /**
   * ç”ŸæˆæŸ¥è¯¢æŒ‡ä»¤
   * @param config è®¾å¤‡é…ç½®
   * @returns Buffer æˆ–å­—ç¬¦ä¸²æŒ‡ä»¤
   */
  generateInstruction(config: InstructionConfig): Buffer | string;

  /**
   * è§£æè®¾å¤‡å“åº”
   * @param buffer å“åº”æ•°æ®
   * @param config è®¾å¤‡é…ç½®
   * @returns è§£æç»“æœ
   */
  parseResponse(buffer: Buffer, config: ParseConfig): ParsedResult;

  /**
   * éªŒè¯å“åº”æ•°æ®
   * @param buffer å“åº”æ•°æ®
   * @returns æ˜¯å¦æœ‰æ•ˆ
   */
  validateResponse(buffer: Buffer): boolean;
}

export interface InstructionConfig {
  pid: number;
  instructName: string;
  address?: number;
  length?: number;
  [key: string]: any;
}

export interface ParseConfig {
  protocol: string;
  constants: Record<string, any>;
  [key: string]: any;
}

export interface ParsedResult {
  success: boolean;
  data: Array<{
    name: string;
    value: number | string;
    unit: string;
    alarm?: boolean;
  }>;
  error?: string;
}
```

#### 2.2.2 Modbus RTU ç­–ç•¥

```typescript
export class ModbusRtuStrategy implements ProtocolStrategy {
  /**
   * ç”Ÿæˆ Modbus RTU æŒ‡ä»¤
   * æ ¼å¼: [Device Address][Function Code][Start Address H][Start Address L][Length H][Length L][CRC16 L][CRC16 H]
   */
  generateInstruction(config: InstructionConfig): Buffer {
    const { pid, instructName, address = 0, length = 1 } = config;

    // Modbus åŠŸèƒ½ç æ˜ å°„
    const functionCodes: Record<string, number> = {
      'READ_HOLDING': 0x03,
      'READ_INPUT': 0x04,
      'WRITE_SINGLE': 0x06,
      'WRITE_MULTIPLE': 0x10,
    };

    const deviceAddress = pid & 0xFF;
    const functionCode = functionCodes[instructName] || 0x03;

    // æ„å»ºæŒ‡ä»¤ï¼ˆä¸å« CRCï¼‰
    const buffer = Buffer.alloc(8);
    buffer[0] = deviceAddress;
    buffer[1] = functionCode;
    buffer[2] = (address >> 8) & 0xFF;  // èµ·å§‹åœ°å€é«˜å­—èŠ‚
    buffer[3] = address & 0xFF;          // èµ·å§‹åœ°å€ä½å­—èŠ‚
    buffer[4] = (length >> 8) & 0xFF;    // é•¿åº¦é«˜å­—èŠ‚
    buffer[5] = length & 0xFF;           // é•¿åº¦ä½å­—èŠ‚

    // è®¡ç®— CRC16
    const crc = this.calculateCrc16(buffer.slice(0, 6));
    buffer[6] = crc & 0xFF;              // CRC ä½å­—èŠ‚
    buffer[7] = (crc >> 8) & 0xFF;       // CRC é«˜å­—èŠ‚

    return buffer;
  }

  /**
   * è§£æ Modbus RTU å“åº”
   * æ ¼å¼: [Device Address][Function Code][Byte Count][Data...][CRC16 L][CRC16 H]
   */
  parseResponse(buffer: Buffer, config: ParseConfig): ParsedResult {
    // éªŒè¯æœ€å°é•¿åº¦
    if (buffer.length < 5) {
      return { success: false, data: [], error: 'Invalid response length' };
    }

    // éªŒè¯ CRC
    if (!this.validateResponse(buffer)) {
      return { success: false, data: [], error: 'CRC validation failed' };
    }

    const deviceAddress = buffer[0];
    const functionCode = buffer[1];
    const byteCount = buffer[2];

    // æ£€æŸ¥å¼‚å¸¸å“åº”
    if (functionCode & 0x80) {
      const exceptionCode = buffer[2];
      return {
        success: false,
        data: [],
        error: `Modbus exception: ${exceptionCode}`
      };
    }

    // æå–æ•°æ®éƒ¨åˆ†
    const dataBuffer = buffer.slice(3, 3 + byteCount);

    // æ ¹æ®åè®®å¸¸é‡æ˜ å°„è§£ææ•°æ®
    const data: ParsedResult['data'] = [];
    const { constants } = config;

    for (let i = 0; i < byteCount; i += 2) {
      const value = dataBuffer.readUInt16BE(i);
      const register = Math.floor(i / 2);

      // æŸ¥æ‰¾å¯¹åº”çš„å¯„å­˜å™¨å®šä¹‰
      const constant = constants[`REG_${register}`];
      if (constant) {
        data.push({
          name: constant.name,
          value: value * (constant.ratio || 1),
          unit: constant.unit || '',
          alarm: this.checkAlarm(value, constant),
        });
      }
    }

    return { success: true, data };
  }

  validateResponse(buffer: Buffer): boolean {
    if (buffer.length < 5) return false;

    const dataPart = buffer.slice(0, -2);
    const receivedCrc = buffer.readUInt16LE(buffer.length - 2);
    const calculatedCrc = this.calculateCrc16(dataPart);

    return receivedCrc === calculatedCrc;
  }

  /**
   * CRC16 è®¡ç®— (Modbus æ ‡å‡†)
   */
  private calculateCrc16(buffer: Buffer): number {
    let crc = 0xFFFF;

    for (let i = 0; i < buffer.length; i++) {
      crc ^= buffer[i];

      for (let j = 0; j < 8; j++) {
        if (crc & 0x0001) {
          crc = (crc >> 1) ^ 0xA001;
        } else {
          crc >>= 1;
        }
      }
    }

    return crc;
  }

  private checkAlarm(value: number, constant: any): boolean {
    if (!constant.alarmThreshold) return false;
    const { min, max } = constant.alarmThreshold;
    return value < min || value > max;
  }
}
```

#### 2.2.3 UTF8 åè®®ç­–ç•¥

```typescript
export class Utf8ProtocolStrategy implements ProtocolStrategy {
  /**
   * ç”Ÿæˆ UTF8 JSON æŒ‡ä»¤
   */
  generateInstruction(config: InstructionConfig): string {
    const { pid, instructName, ...params } = config;

    return JSON.stringify({
      deviceId: pid,
      command: instructName,
      params,
      timestamp: Date.now(),
    });
  }

  /**
   * è§£æ UTF8 JSON å“åº”
   */
  parseResponse(buffer: Buffer, config: ParseConfig): ParsedResult {
    try {
      const jsonStr = buffer.toString('utf8');
      const response = JSON.parse(jsonStr);

      if (!response.success) {
        return {
          success: false,
          data: [],
          error: response.error || 'Unknown error'
        };
      }

      // è½¬æ¢æ•°æ®æ ¼å¼
      const data = Object.entries(response.data || {}).map(([name, item]: [string, any]) => ({
        name,
        value: item.value,
        unit: item.unit || '',
        alarm: item.alarm || false,
      }));

      return { success: true, data };
    } catch (error) {
      return {
        success: false,
        data: [],
        error: `JSON parse error: ${error.message}`
      };
    }
  }

  validateResponse(buffer: Buffer): boolean {
    try {
      const jsonStr = buffer.toString('utf8');
      JSON.parse(jsonStr);
      return true;
    } catch {
      return false;
    }
  }
}
```

#### 2.2.4 Pesiv å¡åè®®ç­–ç•¥

```typescript
export class PesivCardStrategy implements ProtocolStrategy {
  /**
   * ç”Ÿæˆ Pesiv å¡æŒ‡ä»¤
   * æ ¼å¼: è‡ªå®šä¹‰äºŒè¿›åˆ¶åè®®
   */
  generateInstruction(config: InstructionConfig): Buffer {
    const { pid, instructName } = config;

    // Pesiv å¡æŒ‡ä»¤å¤´
    const header = Buffer.from([0xAA, 0x55]);
    const deviceId = Buffer.alloc(2);
    deviceId.writeUInt16LE(pid);

    // æŒ‡ä»¤ç±»å‹
    const commandMap: Record<string, number> = {
      'READ_STATUS': 0x01,
      'READ_DATA': 0x02,
      'WRITE_CONFIG': 0x03,
    };
    const command = Buffer.from([commandMap[instructName] || 0x01]);

    // ç»„è£…æ•°æ®åŒ…
    const packet = Buffer.concat([header, deviceId, command]);

    // æ·»åŠ æ ¡éªŒå’Œ
    const checksum = this.calculateChecksum(packet);
    return Buffer.concat([packet, Buffer.from([checksum])]);
  }

  parseResponse(buffer: Buffer, config: ParseConfig): ParsedResult {
    // éªŒè¯åŒ…å¤´
    if (buffer.length < 4 || buffer[0] !== 0xAA || buffer[1] !== 0x55) {
      return { success: false, data: [], error: 'Invalid packet header' };
    }

    // éªŒè¯æ ¡éªŒå’Œ
    if (!this.validateResponse(buffer)) {
      return { success: false, data: [], error: 'Checksum validation failed' };
    }

    const deviceId = buffer.readUInt16LE(2);
    const command = buffer[4];
    const dataLength = buffer[5];
    const dataBuffer = buffer.slice(6, 6 + dataLength);

    // æ ¹æ®å‘½ä»¤ç±»å‹è§£ææ•°æ®
    const data: ParsedResult['data'] = [];

    switch (command) {
      case 0x01: // READ_STATUS
        data.push({
          name: 'status',
          value: dataBuffer[0],
          unit: '',
        });
        break;

      case 0x02: // READ_DATA
        for (let i = 0; i < dataLength; i += 4) {
          const value = dataBuffer.readFloatLE(i);
          data.push({
            name: `channel_${i / 4}`,
            value,
            unit: 'V',
          });
        }
        break;
    }

    return { success: true, data };
  }

  validateResponse(buffer: Buffer): boolean {
    if (buffer.length < 7) return false;

    const checksum = buffer[buffer.length - 1];
    const calculatedChecksum = this.calculateChecksum(buffer.slice(0, -1));

    return checksum === calculatedChecksum;
  }

  private calculateChecksum(buffer: Buffer): number {
    let sum = 0;
    for (let i = 0; i < buffer.length; i++) {
      sum += buffer[i];
    }
    return sum & 0xFF;
  }
}
```

#### 2.2.5 è‡ªå®šä¹‰è„šæœ¬ç­–ç•¥

```typescript
/**
 * âš ï¸ å®‰å…¨è­¦å‘Šï¼šæ­¤ç­–ç•¥ä½¿ç”¨åŠ¨æ€è„šæœ¬æ‰§è¡Œ
 *
 * ä½¿ç”¨åœºæ™¯ï¼š
 * - æ”¯æŒç”¨æˆ·è‡ªå®šä¹‰åè®®è§£æé€»è¾‘
 * - ç”¨äºç‰¹æ®Šè®¾å¤‡æˆ–ç§æœ‰åè®®
 *
 * å®‰å…¨è€ƒè™‘ï¼š
 * - ä»…é™ç®¡ç†å‘˜é…ç½®
 * - å»ºè®®åœ¨æ²™ç®±ç¯å¢ƒä¸­æ‰§è¡Œï¼ˆå¦‚ä½¿ç”¨ isolated-vmï¼‰
 * - ç”Ÿäº§ç¯å¢ƒåº”å¯ç”¨è„šæœ¬å®¡æ ¸æœºåˆ¶
 * - é™åˆ¶è„šæœ¬æ‰§è¡Œæ—¶é—´å’Œèµ„æºä½¿ç”¨
 */
export class CustomScriptStrategy implements ProtocolStrategy {
  private instructionScript?: (config: InstructionConfig) => Buffer | string;
  private parseScript?: (buffer: Buffer, config: ParseConfig) => ParsedResult;

  constructor(scripts: {
    instructionScript?: string;
    parseScript?: string;
  }) {
    // ç¼–è¯‘ç”¨æˆ·è„šæœ¬ï¼ˆç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨æ²™ç®±ï¼‰
    if (scripts.instructionScript) {
      this.instructionScript = this.compileScript(scripts.instructionScript, ['config']);
    }
    if (scripts.parseScript) {
      this.parseScript = this.compileScript(scripts.parseScript, ['buffer', 'config']);
    }
  }

  /**
   * ç¼–è¯‘ç”¨æˆ·è„šæœ¬åˆ°å‡½æ•°
   * æ³¨æ„ï¼šç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨ isolated-vm æˆ– vm2 è¿›è¡Œæ²™ç®±éš”ç¦»
   */
  private compileScript(scriptCode: string, params: string[]): any {
    try {
      // ç®€å•å®ç°ï¼ˆä¸æ¨èç”Ÿäº§ç¯å¢ƒï¼‰
      // ç”Ÿäº§ç¯å¢ƒåº”ä½¿ç”¨ï¼š
      // const isolate = new ivm.Isolate({ memoryLimit: 128 });
      // const context = isolate.createContextSync();
      // return context.evalSync(scriptCode);

      const funcBody = `
        'use strict';
        ${scriptCode}
      `;
      return new Function(...params, funcBody);
    } catch (error) {
      throw new Error(`Script compilation failed: ${error.message}`);
    }
  }

  generateInstruction(config: InstructionConfig): Buffer | string {
    if (!this.instructionScript) {
      throw new Error('Instruction script not configured');
    }

    try {
      const result = this.instructionScript(config);

      // éªŒè¯è¿”å›ç±»å‹
      if (!Buffer.isBuffer(result) && typeof result !== 'string') {
        throw new Error('Script must return Buffer or string');
      }

      return result;
    } catch (error) {
      throw new Error(`Instruction generation failed: ${error.message}`);
    }
  }

  parseResponse(buffer: Buffer, config: ParseConfig): ParsedResult {
    if (!this.parseScript) {
      throw new Error('Parse script not configured');
    }

    try {
      return this.parseScript(buffer, config);
    } catch (error) {
      return {
        success: false,
        data: [],
        error: `Parse failed: ${error.message}`,
      };
    }
  }

  validateResponse(buffer: Buffer): boolean {
    // è‡ªå®šä¹‰è„šæœ¬ç­–ç•¥ç”±ç”¨æˆ·è„šæœ¬è‡ªè¡ŒéªŒè¯
    return buffer.length > 0;
  }
}
```

#### 2.2.6 åè®®ç­–ç•¥å·¥å‚

```typescript
export class ProtocolStrategyFactory {
  private static strategies = new Map<string, ProtocolStrategy>();

  /**
   * æ³¨å†Œåè®®ç­–ç•¥
   */
  static register(protocolType: string, strategy: ProtocolStrategy) {
    this.strategies.set(protocolType, strategy);
  }

  /**
   * è·å–åè®®ç­–ç•¥
   */
  static getStrategy(protocolType: string): ProtocolStrategy {
    const strategy = this.strategies.get(protocolType);
    if (!strategy) {
      throw new Error(`Protocol strategy not found: ${protocolType}`);
    }
    return strategy;
  }

  /**
   * åˆå§‹åŒ–é»˜è®¤ç­–ç•¥
   */
  static initialize() {
    this.register('modbus_rtu', new ModbusRtuStrategy());
    this.register('utf8', new Utf8ProtocolStrategy());
    this.register('pesiv_card', new PesivCardStrategy());

    // è‡ªå®šä¹‰è„šæœ¬ç­–ç•¥éœ€è¦ä»æ•°æ®åº“åŠ è½½
    // åœ¨åº”ç”¨å¯åŠ¨æ—¶åŠ¨æ€æ³¨å†Œ
  }

  /**
   * ä»æ•°æ®åº“åŠ è½½è‡ªå®šä¹‰åè®®
   */
  static async loadCustomProtocols(protocolRepo: ProtocolRepository) {
    const customProtocols = await protocolRepo.findCustomProtocols();

    for (const protocol of customProtocols) {
      const strategy = new CustomScriptStrategy({
        instructionScript: protocol.instructionScript,
        parseScript: protocol.parseScript,
      });

      this.register(`custom_${protocol.id}`, strategy);
    }
  }
}

// åˆå§‹åŒ–
ProtocolStrategyFactory.initialize();
```

### 2.3 å‘Šè­¦æ£€æµ‹ç­–ç•¥

#### 2.3.1 ç­–ç•¥æ¥å£

```typescript
export interface AlarmStrategy {
  /**
   * æ£€æŸ¥æ˜¯å¦è§¦å‘å‘Šè­¦
   * @param data è®¾å¤‡æ•°æ®
   * @param config å‘Šè­¦é…ç½®
   * @returns å‘Šè­¦ä¿¡æ¯ï¼ˆæ— å‘Šè­¦è¿”å› nullï¼‰
   */
  check(data: DeviceData, config: AlarmConfig): AlarmInfo | null;
}

export interface DeviceData {
  mac: string;
  pid: number;
  results: Array<{
    name: string;
    value: number | string;
    unit: string;
    timestamp: Date;
  }>;
}

export interface AlarmConfig {
  type: 'threshold' | 'state_change' | 'offline';
  params: Record<string, any>;
  severity: 'info' | 'warning' | 'critical';
  [key: string]: any;
}

export interface AlarmInfo {
  type: string;
  severity: 'info' | 'warning' | 'critical';
  message: string;
  data: Record<string, any>;
  timestamp: Date;
}
```

#### 2.3.2 é˜ˆå€¼å‘Šè­¦ç­–ç•¥

```typescript
export class ThresholdAlarmStrategy implements AlarmStrategy {
  check(data: DeviceData, config: AlarmConfig): AlarmInfo | null {
    const { params } = config;
    const { fieldName, min, max, operator = 'between' } = params;

    // æŸ¥æ‰¾å¯¹åº”å­—æ®µ
    const field = data.results.find((r) => r.name === fieldName);
    if (!field || typeof field.value !== 'number') {
      return null;
    }

    const value = field.value;
    let triggered = false;
    let message = '';

    // åˆ¤æ–­å‘Šè­¦æ¡ä»¶
    switch (operator) {
      case 'between':
        triggered = value < min || value > max;
        message = `${fieldName} = ${value}${field.unit} (æ­£å¸¸èŒƒå›´: ${min}-${max}${field.unit})`;
        break;

      case 'gt':
        triggered = value > max;
        message = `${fieldName} = ${value}${field.unit} è¶…è¿‡ä¸Šé™ ${max}${field.unit}`;
        break;

      case 'lt':
        triggered = value < min;
        message = `${fieldName} = ${value}${field.unit} ä½äºä¸‹é™ ${min}${field.unit}`;
        break;

      case 'eq':
        triggered = value === params.target;
        message = `${fieldName} = ${value}${field.unit} ç­‰äºå‘Šè­¦å€¼ ${params.target}${field.unit}`;
        break;
    }

    if (!triggered) return null;

    return {
      type: 'threshold',
      severity: config.severity,
      message: `é˜ˆå€¼å‘Šè­¦: ${message}`,
      data: {
        mac: data.mac,
        pid: data.pid,
        fieldName,
        value,
        unit: field.unit,
        threshold: { min, max, operator },
      },
      timestamp: new Date(),
    };
  }
}
```

#### 2.3.3 çŠ¶æ€å˜åŒ–å‘Šè­¦ç­–ç•¥

```typescript
export class StateChangeAlarmStrategy implements AlarmStrategy {
  private stateCache = new Map<string, any>();

  check(data: DeviceData, config: AlarmConfig): AlarmInfo | null {
    const { params } = config;
    const { fieldName, triggerOn = 'any_change' } = params;

    const field = data.results.find((r) => r.name === fieldName);
    if (!field) return null;

    const key = `${data.mac}:${data.pid}:${fieldName}`;
    const previousValue = this.stateCache.get(key);
    const currentValue = field.value;

    // æ›´æ–°ç¼“å­˜
    this.stateCache.set(key, currentValue);

    // é¦–æ¬¡è®°å½•ï¼Œä¸è§¦å‘å‘Šè­¦
    if (previousValue === undefined) return null;

    let triggered = false;
    let message = '';

    switch (triggerOn) {
      case 'any_change':
        triggered = previousValue !== currentValue;
        message = `${fieldName} çŠ¶æ€å˜åŒ–: ${previousValue} â†’ ${currentValue}`;
        break;

      case 'to_value':
        triggered = currentValue === params.targetValue;
        message = `${fieldName} å˜ä¸º ${currentValue}`;
        break;

      case 'from_to':
        triggered = previousValue === params.fromValue && currentValue === params.toValue;
        message = `${fieldName} ä» ${params.fromValue} å˜ä¸º ${params.toValue}`;
        break;
    }

    if (!triggered) return null;

    return {
      type: 'state_change',
      severity: config.severity,
      message: `çŠ¶æ€å˜åŒ–å‘Šè­¦: ${message}`,
      data: {
        mac: data.mac,
        pid: data.pid,
        fieldName,
        previousValue,
        currentValue,
      },
      timestamp: new Date(),
    };
  }
}
```

#### 2.3.4 ç¦»çº¿å‘Šè­¦ç­–ç•¥

```typescript
export class OfflineAlarmStrategy implements AlarmStrategy {
  private lastSeenCache = new Map<string, Date>();

  check(data: DeviceData, config: AlarmConfig): AlarmInfo | null {
    const { params } = config;
    const { offlineThresholdMinutes = 5 } = params;

    const key = `${data.mac}:${data.pid}`;
    const now = new Date();
    const lastSeen = this.lastSeenCache.get(key);

    // æ›´æ–°æœ€ååœ¨çº¿æ—¶é—´
    this.lastSeenCache.set(key, now);

    // é¦–æ¬¡è®°å½•
    if (!lastSeen) return null;

    const offlineMinutes = (now.getTime() - lastSeen.getTime()) / 60000;

    if (offlineMinutes < offlineThresholdMinutes) return null;

    return {
      type: 'offline',
      severity: config.severity,
      message: `è®¾å¤‡ç¦»çº¿å‘Šè­¦: å·²ç¦»çº¿ ${Math.floor(offlineMinutes)} åˆ†é’Ÿ`,
      data: {
        mac: data.mac,
        pid: data.pid,
        lastSeen,
        offlineMinutes,
        threshold: offlineThresholdMinutes,
      },
      timestamp: now,
    };
  }

  /**
   * å®šæœŸæ¸…ç†è¿‡æœŸç¼“å­˜
   */
  cleanupCache(retentionHours = 24) {
    const now = new Date();
    const threshold = now.getTime() - retentionHours * 3600000;

    for (const [key, lastSeen] of this.lastSeenCache.entries()) {
      if (lastSeen.getTime() < threshold) {
        this.lastSeenCache.delete(key);
      }
    }
  }
}
```

#### 2.3.5 å‘Šè­¦ç­–ç•¥ç»„åˆå™¨

```typescript
export class AlarmStrategyComposer {
  private strategies: AlarmStrategy[] = [];

  /**
   * æ·»åŠ å‘Šè­¦ç­–ç•¥
   */
  addStrategy(strategy: AlarmStrategy) {
    this.strategies.push(strategy);
    return this;
  }

  /**
   * æ£€æŸ¥æ‰€æœ‰ç­–ç•¥ï¼Œè¿”å›æ‰€æœ‰è§¦å‘çš„å‘Šè­¦
   */
  async checkAll(
    data: DeviceData,
    configs: AlarmConfig[]
  ): Promise<AlarmInfo[]> {
    const alarms: AlarmInfo[] = [];

    for (const config of configs) {
      // æ ¹æ®é…ç½®ç±»å‹é€‰æ‹©ç­–ç•¥
      const strategy = this.getStrategy(config.type);
      if (!strategy) continue;

      const alarm = strategy.check(data, config);
      if (alarm) {
        alarms.push(alarm);
      }
    }

    return alarms;
  }

  private getStrategy(type: string): AlarmStrategy | null {
    // ç®€åŒ–ç‰ˆï¼šå®é™…åº”ç”¨ä¸­åº”ä½¿ç”¨å·¥å‚æ¨¡å¼
    const strategyMap: Record<string, AlarmStrategy> = {
      threshold: new ThresholdAlarmStrategy(),
      state_change: new StateChangeAlarmStrategy(),
      offline: new OfflineAlarmStrategy(),
    };

    return strategyMap[type] || null;
  }
}
```

### 2.4 é€šçŸ¥æ¨é€ç­–ç•¥

#### 2.4.1 ç­–ç•¥æ¥å£

```typescript
export interface NotificationStrategy {
  /**
   * å‘é€é€šçŸ¥
   * @param alarm å‘Šè­¦ä¿¡æ¯
   * @param recipients æ¥æ”¶è€…åˆ—è¡¨
   */
  send(alarm: AlarmInfo, recipients: Recipient[]): Promise<SendResult>;
}

export interface Recipient {
  type: 'wechat' | 'sms' | 'email' | 'dingtalk';
  target: string; // openid, phone, email, webhook
  [key: string]: any;
}

export interface SendResult {
  success: boolean;
  sent: number;
  failed: number;
  errors: Array<{ recipient: string; error: string }>;
}
```

#### 2.4.2 å¾®ä¿¡é€šçŸ¥ç­–ç•¥

```typescript
export class WeChatNotificationStrategy implements NotificationStrategy {
  constructor(private wechatService: WeChatService) {}

  async send(alarm: AlarmInfo, recipients: Recipient[]): Promise<SendResult> {
    const wechatRecipients = recipients.filter((r) => r.type === 'wechat');

    const results = await Promise.allSettled(
      wechatRecipients.map((recipient) =>
        this.sendToUser(alarm, recipient.target)
      )
    );

    const sent = results.filter((r) => r.status === 'fulfilled').length;
    const failed = results.length - sent;
    const errors = results
      .filter((r): r is PromiseRejectedResult => r.status === 'rejected')
      .map((r, i) => ({
        recipient: wechatRecipients[i].target,
        error: r.reason.message,
      }));

    return { success: sent > 0, sent, failed, errors };
  }

  private async sendToUser(alarm: AlarmInfo, openid: string) {
    // å¾®ä¿¡æ¨¡æ¿æ¶ˆæ¯
    await this.wechatService.sendTemplateMessage({
      touser: openid,
      template_id: this.getTemplateId(alarm.severity),
      data: {
        first: { value: alarm.message, color: this.getSeverityColor(alarm.severity) },
        keyword1: { value: alarm.data.mac },
        keyword2: { value: alarm.data.fieldName || 'N/A' },
        keyword3: { value: alarm.timestamp.toLocaleString('zh-CN') },
        remark: { value: 'è¯·åŠæ—¶å¤„ç†' },
      },
    });
  }

  private getTemplateId(severity: string): string {
    const templates = {
      info: 'TPL_INFO_ID',
      warning: 'TPL_WARNING_ID',
      critical: 'TPL_CRITICAL_ID',
    };
    return templates[severity] || templates.info;
  }

  private getSeverityColor(severity: string): string {
    const colors = {
      info: '#00CC00',
      warning: '#FF9900',
      critical: '#FF0000',
    };
    return colors[severity] || colors.info;
  }
}
```

#### 2.4.3 çŸ­ä¿¡é€šçŸ¥ç­–ç•¥

```typescript
export class SmsNotificationStrategy implements NotificationStrategy {
  constructor(private smsService: SmsService) {}

  async send(alarm: AlarmInfo, recipients: Recipient[]): Promise<SendResult> {
    const smsRecipients = recipients.filter((r) => r.type === 'sms');

    const results = await Promise.allSettled(
      smsRecipients.map((recipient) =>
        this.sendToPhone(alarm, recipient.target)
      )
    );

    const sent = results.filter((r) => r.status === 'fulfilled').length;
    const failed = results.length - sent;
    const errors = results
      .filter((r): r is PromiseRejectedResult => r.status === 'rejected')
      .map((r, i) => ({
        recipient: smsRecipients[i].target,
        error: r.reason.message,
      }));

    return { success: sent > 0, sent, failed, errors };
  }

  private async sendToPhone(alarm: AlarmInfo, phone: string) {
    const message = this.formatSmsMessage(alarm);

    await this.smsService.send({
      phone,
      template: this.getTemplateCode(alarm.severity),
      params: {
        device: alarm.data.mac,
        content: message,
        time: alarm.timestamp.toLocaleString('zh-CN'),
      },
    });
  }

  private formatSmsMessage(alarm: AlarmInfo): string {
    return `ã€å‘Šè­¦ã€‘${alarm.message}`;
  }

  private getTemplateCode(severity: string): string {
    const templates = {
      info: 'SMS_INFO_TEMPLATE',
      warning: 'SMS_WARNING_TEMPLATE',
      critical: 'SMS_CRITICAL_TEMPLATE',
    };
    return templates[severity] || templates.info;
  }
}
```

#### 2.4.4 é‚®ä»¶é€šçŸ¥ç­–ç•¥

```typescript
export class EmailNotificationStrategy implements NotificationStrategy {
  constructor(private emailService: EmailService) {}

  async send(alarm: AlarmInfo, recipients: Recipient[]): Promise<SendResult> {
    const emailRecipients = recipients.filter((r) => r.type === 'email');

    const results = await Promise.allSettled(
      emailRecipients.map((recipient) =>
        this.sendToEmail(alarm, recipient.target)
      )
    );

    const sent = results.filter((r) => r.status === 'fulfilled').length;
    const failed = results.length - sent;
    const errors = results
      .filter((r): r is PromiseRejectedResult => r.status === 'rejected')
      .map((r, i) => ({
        recipient: emailRecipients[i].target,
        error: r.reason.message,
      }));

    return { success: sent > 0, sent, failed, errors };
  }

  private async sendToEmail(alarm: AlarmInfo, email: string) {
    const html = this.generateHtmlEmail(alarm);

    await this.emailService.send({
      to: email,
      subject: `ã€${alarm.severity.toUpperCase()}ã€‘è®¾å¤‡å‘Šè­¦é€šçŸ¥`,
      html,
    });
  }

  private generateHtmlEmail(alarm: AlarmInfo): string {
    const severityColors = {
      info: '#00CC00',
      warning: '#FF9900',
      critical: '#FF0000',
    };
    const color = severityColors[alarm.severity];

    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <style>
          body { font-family: Arial, sans-serif; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header { background: ${color}; color: white; padding: 15px; border-radius: 5px 5px 0 0; }
          .content { border: 1px solid #ddd; padding: 20px; border-radius: 0 0 5px 5px; }
          .field { margin: 10px 0; }
          .label { font-weight: bold; color: #555; }
          .value { color: #000; }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h2>è®¾å¤‡å‘Šè­¦é€šçŸ¥</h2>
          </div>
          <div class="content">
            <div class="field">
              <span class="label">å‘Šè­¦ç±»å‹ï¼š</span>
              <span class="value">${alarm.type}</span>
            </div>
            <div class="field">
              <span class="label">å‘Šè­¦çº§åˆ«ï¼š</span>
              <span class="value" style="color: ${color}">${alarm.severity.toUpperCase()}</span>
            </div>
            <div class="field">
              <span class="label">å‘Šè­¦å†…å®¹ï¼š</span>
              <span class="value">${alarm.message}</span>
            </div>
            <div class="field">
              <span class="label">è®¾å¤‡ MACï¼š</span>
              <span class="value">${alarm.data.mac}</span>
            </div>
            <div class="field">
              <span class="label">è®¾å¤‡ PIDï¼š</span>
              <span class="value">${alarm.data.pid}</span>
            </div>
            <div class="field">
              <span class="label">å‘Šè­¦æ—¶é—´ï¼š</span>
              <span class="value">${alarm.timestamp.toLocaleString('zh-CN')}</span>
            </div>
            <hr>
            <p style="color: #888; font-size: 12px;">
              æ­¤é‚®ä»¶ç”± UART æœåŠ¡å™¨è‡ªåŠ¨å‘é€ï¼Œè¯·å‹¿å›å¤ã€‚
            </p>
          </div>
        </div>
      </body>
      </html>
    `;
  }
}
```

#### 2.4.5 é’‰é’‰é€šçŸ¥ç­–ç•¥

```typescript
export class DingTalkNotificationStrategy implements NotificationStrategy {
  constructor(private dingTalkService: DingTalkService) {}

  async send(alarm: AlarmInfo, recipients: Recipient[]): Promise<SendResult> {
    const dingTalkRecipients = recipients.filter((r) => r.type === 'dingtalk');

    const results = await Promise.allSettled(
      dingTalkRecipients.map((recipient) =>
        this.sendToWebhook(alarm, recipient.target)
      )
    );

    const sent = results.filter((r) => r.status === 'fulfilled').length;
    const failed = results.length - sent;
    const errors = results
      .filter((r): r is PromiseRejectedResult => r.status === 'rejected')
      .map((r, i) => ({
        recipient: dingTalkRecipients[i].target,
        error: r.reason.message,
      }));

    return { success: sent > 0, sent, failed, errors };
  }

  private async sendToWebhook(alarm: AlarmInfo, webhook: string) {
    const markdown = this.formatMarkdown(alarm);

    await this.dingTalkService.sendMarkdown({
      webhook,
      title: 'è®¾å¤‡å‘Šè­¦é€šçŸ¥',
      text: markdown,
    });
  }

  private formatMarkdown(alarm: AlarmInfo): string {
    const severityEmoji = {
      info: 'â„¹ï¸',
      warning: 'âš ï¸',
      critical: 'ğŸš¨',
    };
    const emoji = severityEmoji[alarm.severity];

    return `
## ${emoji} è®¾å¤‡å‘Šè­¦é€šçŸ¥

**å‘Šè­¦ç±»å‹ï¼š** ${alarm.type}

**å‘Šè­¦çº§åˆ«ï¼š** ${alarm.severity.toUpperCase()}

**å‘Šè­¦å†…å®¹ï¼š** ${alarm.message}

**è®¾å¤‡ä¿¡æ¯ï¼š**
- MAC: \`${alarm.data.mac}\`
- PID: \`${alarm.data.pid}\`
${alarm.data.fieldName ? `- å­—æ®µ: \`${alarm.data.fieldName}\`` : ''}

**å‘Šè­¦æ—¶é—´ï¼š** ${alarm.timestamp.toLocaleString('zh-CN')}

---
> è¯·åŠæ—¶å¤„ç†å‘Šè­¦
    `.trim();
  }
}
```

#### 2.4.6 é€šçŸ¥ç­–ç•¥å·¥å‚

```typescript
export class NotificationStrategyFactory {
  private strategies = new Map<string, NotificationStrategy>();

  constructor(
    wechatService: WeChatService,
    smsService: SmsService,
    emailService: EmailService,
    dingTalkService: DingTalkService
  ) {
    this.strategies.set('wechat', new WeChatNotificationStrategy(wechatService));
    this.strategies.set('sms', new SmsNotificationStrategy(smsService));
    this.strategies.set('email', new EmailNotificationStrategy(emailService));
    this.strategies.set('dingtalk', new DingTalkNotificationStrategy(dingTalkService));
  }

  /**
   * å‘é€å¤šæ¸ é“é€šçŸ¥
   */
  async sendMultiChannel(
    alarm: AlarmInfo,
    recipients: Recipient[]
  ): Promise<Record<string, SendResult>> {
    // æŒ‰ç±»å‹åˆ†ç»„
    const groupedRecipients = new Map<string, Recipient[]>();
    for (const recipient of recipients) {
      if (!groupedRecipients.has(recipient.type)) {
        groupedRecipients.set(recipient.type, []);
      }
      groupedRecipients.get(recipient.type)!.push(recipient);
    }

    // å¹¶è¡Œå‘é€
    const results: Record<string, SendResult> = {};
    await Promise.all(
      Array.from(groupedRecipients.entries()).map(async ([type, recs]) => {
        const strategy = this.strategies.get(type);
        if (strategy) {
          results[type] = await strategy.send(alarm, recs);
        }
      })
    );

    return results;
  }
}
```

---

## 3. å®ä½“ç±»è®¾è®¡

### 3.1 Terminal å®ä½“

```typescript
import { ObjectId } from 'mongodb';
import type { MountDevice } from './mount-device.entity';

/**
 * ç»ˆç«¯ï¼ˆDTUï¼‰å®ä½“
 * è´Ÿè´£ç»ˆç«¯çŠ¶æ€ç®¡ç†ã€è®¾å¤‡ç®¡ç†ã€ç»Ÿè®¡åŠŸèƒ½
 */
export class Terminal {
  _id?: ObjectId;
  DevMac: string;
  name: string;
  online: boolean;
  mountDevs: MountDevice[];

  // ç½‘ç»œä¿¡æ¯
  ICCID?: string;
  ip?: string;
  port?: number;
  jw?: string;

  // ç³»ç»Ÿä¿¡æ¯
  uptime: number;
  loadavg: [number, number, number];
  freemem: number;
  totalmem: number;

  // æ—¶é—´æˆ³
  AT: Date;
  UT: Date;

  constructor(data: Partial<Terminal>) {
    Object.assign(this, {
      online: false,
      mountDevs: [],
      uptime: 0,
      loadavg: [0, 0, 0],
      freemem: 0,
      totalmem: 0,
      AT: new Date(),
      UT: new Date(),
      ...data,
    });
  }

  // ============ çŠ¶æ€ç®¡ç† ============

  /**
   * è®¾ç½®ç»ˆç«¯åœ¨çº¿çŠ¶æ€
   */
  setOnline(online: boolean) {
    this.online = online;
    this.UT = new Date();

    // å¦‚æœç»ˆç«¯ç¦»çº¿ï¼Œæ‰€æœ‰æŒ‚è½½è®¾å¤‡ä¹Ÿç¦»çº¿
    if (!online) {
      this.mountDevs.forEach((dev) => dev.setOnline(false));
    }
  }

  /**
   * æ›´æ–°ç³»ç»Ÿä¿¡æ¯
   */
  updateSystemInfo(info: {
    uptime?: number;
    loadavg?: [number, number, number];
    freemem?: number;
    totalmem?: number;
  }) {
    Object.assign(this, info);
    this.UT = new Date();
  }

  /**
   * æ›´æ–°ç½‘ç»œä¿¡æ¯
   */
  updateNetworkInfo(info: {
    ip?: string;
    port?: number;
    jw?: string;
  }) {
    Object.assign(this, info);
    this.UT = new Date();
  }

  // ============ è®¾å¤‡ç®¡ç† ============

  /**
   * æ·»åŠ æŒ‚è½½è®¾å¤‡
   */
  addMountDevice(device: MountDevice): boolean {
    // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
    const exists = this.mountDevs.some((d) => d.pid === device.pid);
    if (exists) return false;

    this.mountDevs.push(device);
    this.UT = new Date();
    return true;
  }

  /**
   * ç§»é™¤æŒ‚è½½è®¾å¤‡
   */
  removeMountDevice(pid: number): boolean {
    const index = this.mountDevs.findIndex((d) => d.pid === pid);
    if (index === -1) return false;

    this.mountDevs.splice(index, 1);
    this.UT = new Date();
    return true;
  }

  /**
   * æŸ¥æ‰¾æŒ‚è½½è®¾å¤‡
   */
  findMountDevice(pid: number): MountDevice | undefined {
    return this.mountDevs.find((d) => d.pid === pid);
  }

  /**
   * æ›´æ–°æŒ‚è½½è®¾å¤‡åœ¨çº¿çŠ¶æ€
   */
  updateMountDeviceOnline(pid: number, online: boolean): boolean {
    const device = this.findMountDevice(pid);
    if (!device) return false;

    device.setOnline(online);
    this.UT = new Date();
    return true;
  }

  /**
   * è·å–åœ¨çº¿çš„æŒ‚è½½è®¾å¤‡
   */
  getOnlineMountDevices(): MountDevice[] {
    return this.mountDevs.filter((d) => d.online);
  }

  /**
   * è·å–éœ€è¦æŸ¥è¯¢çš„è®¾å¤‡åˆ—è¡¨
   */
  getQueryableDevices(): MountDevice[] {
    return this.online ? this.getOnlineMountDevices() : [];
  }

  // ============ ç»Ÿè®¡åŠŸèƒ½ ============

  /**
   * è®¡ç®—æŸ¥è¯¢é—´éš”ï¼ˆæ¯«ç§’ï¼‰
   * åŸºäºè®¾å¤‡æ•°é‡å’Œç½‘ç»œç±»å‹åŠ¨æ€è®¡ç®—
   */
  calculateQueryInterval(): number {
    const deviceCount = this.getOnlineMountDevices().length;
    if (deviceCount === 0) return 0;

    // åŸºç¡€é—´éš”ï¼š4G ä¸º 1000msï¼Œå…¶ä»–ä¸º 500ms
    let baseInterval = this.ICCID ? 1000 : 500;

    // å¦‚æœæœ‰æµé‡é™åˆ¶ï¼Œè°ƒæ•´é—´éš”
    const flowResource = this.getFlowResource();
    if (flowResource && flowResource < 512) {
      baseInterval *= (512 / flowResource) * 2;
    }

    // æ€»é—´éš” = è®¾å¤‡æ•°é‡ * åŸºç¡€é—´éš”ï¼Œæœ€å° 5 ç§’
    return Math.max(deviceCount * baseInterval, 5000);
  }

  /**
   * è·å–æµé‡èµ„æºï¼ˆMBï¼‰
   * éœ€è¦ä»å¤–éƒ¨æœåŠ¡è·å–
   */
  private getFlowResource(): number | null {
    // æ­¤å¤„åº”è°ƒç”¨ IoT æœåŠ¡è·å–å®é™…æµé‡
    // æš‚æ—¶è¿”å› null
    return null;
  }

  /**
   * è·å–å†…å­˜ä½¿ç”¨ç‡
   */
  getMemoryUsage(): number {
    if (this.totalmem === 0) return 0;
    return ((this.totalmem - this.freemem) / this.totalmem) * 100;
  }

  /**
   * è·å–è´Ÿè½½çŠ¶æ€
   */
  getLoadStatus(): 'low' | 'normal' | 'high' {
    const load = this.loadavg[0]; // 1 åˆ†é’Ÿè´Ÿè½½
    if (load < 1) return 'low';
    if (load < 2) return 'normal';
    return 'high';
  }

  /**
   * è·å–åœ¨çº¿æ—¶é•¿ï¼ˆç§’ï¼‰
   */
  getOnlineDuration(): number {
    return this.uptime;
  }

  /**
   * è·å–ç»Ÿè®¡ä¿¡æ¯
   */
  getStatistics() {
    return {
      totalDevices: this.mountDevs.length,
      onlineDevices: this.getOnlineMountDevices().length,
      memoryUsage: this.getMemoryUsage(),
      loadStatus: this.getLoadStatus(),
      onlineDuration: this.getOnlineDuration(),
      queryInterval: this.calculateQueryInterval(),
    };
  }

  // ============ éªŒè¯ ============

  /**
   * éªŒè¯ MAC åœ°å€æ ¼å¼
   */
  static isValidMac(mac: string): boolean {
    return /^[0-9A-Fa-f]{12}$/.test(mac);
  }

  /**
   * éªŒè¯ç»ˆç«¯æ•°æ®å®Œæ•´æ€§
   */
  validate(): string[] {
    const errors: string[] = [];

    if (!Terminal.isValidMac(this.DevMac)) {
      errors.push('Invalid MAC address format');
    }

    if (!this.name || this.name.length === 0) {
      errors.push('Terminal name is required');
    }

    if (this.ip && !/^(\d{1,3}\.){3}\d{1,3}$/.test(this.ip)) {
      errors.push('Invalid IP address format');
    }

    if (this.port && (this.port < 1 || this.port > 65535)) {
      errors.push('Port must be between 1 and 65535');
    }

    return errors;
  }

  // ============ åºåˆ—åŒ– ============

  /**
   * è½¬æ¢ä¸º JSON å¯¹è±¡
   */
  toJSON() {
    return {
      _id: this._id,
      DevMac: this.DevMac,
      name: this.name,
      online: this.online,
      mountDevs: this.mountDevs.map((d) => d.toJSON()),
      ICCID: this.ICCID,
      ip: this.ip,
      port: this.port,
      jw: this.jw,
      uptime: this.uptime,
      loadavg: this.loadavg,
      freemem: this.freemem,
      totalmem: this.totalmem,
      AT: this.AT,
      UT: this.UT,
      statistics: this.getStatistics(),
    };
  }

  /**
   * è½¬æ¢ä¸ºç®€åŒ– JSONï¼ˆç”¨äºåˆ—è¡¨å±•ç¤ºï¼‰
   */
  toSimpleJSON() {
    return {
      _id: this._id,
      DevMac: this.DevMac,
      name: this.name,
      online: this.online,
      deviceCount: this.mountDevs.length,
      onlineDeviceCount: this.getOnlineMountDevices().length,
      memoryUsage: this.getMemoryUsage(),
      UT: this.UT,
    };
  }
}
```

### 3.2 MountDevice å®ä½“

```typescript
/**
 * æŒ‚è½½è®¾å¤‡å®ä½“
 * è´Ÿè´£è®¾å¤‡æŸ¥è¯¢ã€ç»“æœç®¡ç†ã€åè®®å¤„ç†
 */
export class MountDevice {
  pid: number;
  Type: string;
  mountDev: string;
  protocol: string;
  online: boolean;
  updatedAt: Date;

  // è¿è¡Œæ—¶æ•°æ®ï¼ˆä¸å­˜å‚¨åˆ°æ•°æ®åº“ï¼‰
  private lastQueryTime?: Date;
  private queryCount: number = 0;
  private lastResult?: any;

  constructor(data: Partial<MountDevice>) {
    Object.assign(this, {
      online: false,
      updatedAt: new Date(),
      ...data,
    });
  }

  // ============ æŸ¥è¯¢ç®¡ç† ============

  /**
   * è®¾ç½®è®¾å¤‡åœ¨çº¿çŠ¶æ€
   */
  setOnline(online: boolean) {
    this.online = online;
    this.updatedAt = new Date();
  }

  /**
   * è®°å½•æŸ¥è¯¢æ—¶é—´
   */
  recordQuery() {
    this.lastQueryTime = new Date();
    this.queryCount++;
  }

  /**
   * è·å–ä¸Šæ¬¡æŸ¥è¯¢æ—¶é—´
   */
  getLastQueryTime(): Date | undefined {
    return this.lastQueryTime;
  }

  /**
   * è·å–æŸ¥è¯¢æ¬¡æ•°
   */
  getQueryCount(): number {
    return this.queryCount;
  }

  /**
   * é‡ç½®æŸ¥è¯¢ç»Ÿè®¡
   */
  resetQueryStats() {
    this.lastQueryTime = undefined;
    this.queryCount = 0;
  }

  /**
   * æ£€æŸ¥æ˜¯å¦éœ€è¦æŸ¥è¯¢
   * @param intervalMs æŸ¥è¯¢é—´éš”ï¼ˆæ¯«ç§’ï¼‰
   */
  shouldQuery(intervalMs: number): boolean {
    if (!this.online) return false;
    if (!this.lastQueryTime) return true;

    const elapsed = Date.now() - this.lastQueryTime.getTime();
    return elapsed >= intervalMs;
  }

  // ============ ç»“æœç®¡ç† ============

  /**
   * ä¿å­˜æŸ¥è¯¢ç»“æœ
   */
  saveResult(result: any) {
    this.lastResult = result;
    this.updatedAt = new Date();
  }

  /**
   * è·å–æœ€åç»“æœ
   */
  getLastResult(): any {
    return this.lastResult;
  }

  /**
   * æ¸…é™¤ç»“æœç¼“å­˜
   */
  clearResult() {
    this.lastResult = undefined;
  }

  // ============ åè®®å¤„ç† ============

  /**
   * è·å–åè®®ç­–ç•¥
   */
  getProtocolStrategy(): ProtocolStrategy {
    return ProtocolStrategyFactory.getStrategy(this.protocol);
  }

  /**
   * ç”ŸæˆæŸ¥è¯¢æŒ‡ä»¤
   */
  generateInstruction(instructName: string, config?: any): Buffer | string {
    const strategy = this.getProtocolStrategy();
    return strategy.generateInstruction({
      pid: this.pid,
      instructName,
      ...config,
    });
  }

  /**
   * è§£æå“åº”æ•°æ®
   */
  parseResponse(buffer: Buffer, config: any): ParsedResult {
    const strategy = this.getProtocolStrategy();
    return strategy.parseResponse(buffer, config);
  }

  // ============ éªŒè¯ ============

  /**
   * éªŒè¯è®¾å¤‡æ•°æ®
   */
  validate(): string[] {
    const errors: string[] = [];

    if (!this.pid || this.pid <= 0) {
      errors.push('Invalid PID');
    }

    if (!this.Type || this.Type.length === 0) {
      errors.push('Device type is required');
    }

    if (!this.mountDev || this.mountDev.length === 0) {
      errors.push('Mount device name is required');
    }

    if (!this.protocol || this.protocol.length === 0) {
      errors.push('Protocol is required');
    }

    return errors;
  }

  // ============ åºåˆ—åŒ– ============

  /**
   * è½¬æ¢ä¸º JSON
   */
  toJSON() {
    return {
      pid: this.pid,
      Type: this.Type,
      mountDev: this.mountDev,
      protocol: this.protocol,
      online: this.online,
      updatedAt: this.updatedAt,
      lastQueryTime: this.lastQueryTime,
      queryCount: this.queryCount,
    };
  }
}
```

### 3.3 QueryResult å®ä½“

```typescript
/**
 * æŸ¥è¯¢ç»“æœå®ä½“
 * è´Ÿè´£æ•°æ®éªŒè¯ã€è§£æã€å‘Šè­¦æ£€æŸ¥
 */
export class QueryResult {
  mac: string;
  pid: number;
  protocol: string;
  buffer: Buffer;
  timestamp: Date;

  private parsed?: ParsedResult;
  private alarms?: AlarmInfo[];

  constructor(data: {
    mac: string;
    pid: number;
    protocol: string;
    buffer: Buffer | string;
  }) {
    this.mac = data.mac;
    this.pid = data.pid;
    this.protocol = data.protocol;
    this.buffer = typeof data.buffer === 'string'
      ? Buffer.from(data.buffer, 'hex')
      : data.buffer;
    this.timestamp = new Date();
  }

  // ============ æ•°æ®éªŒè¯ ============

  /**
   * éªŒè¯ç»“æœæ•°æ®
   */
  validate(): boolean {
    if (!Terminal.isValidMac(this.mac)) return false;
    if (this.pid <= 0) return false;
    if (this.buffer.length === 0) return false;
    return true;
  }

  /**
   * éªŒè¯åè®®å“åº”
   */
  validateProtocol(): boolean {
    const strategy = ProtocolStrategyFactory.getStrategy(this.protocol);
    return strategy.validateResponse(this.buffer);
  }

  // ============ æ•°æ®è§£æ ============

  /**
   * è§£ææ•°æ®
   */
  async parse(config: ParseConfig): Promise<ParsedResult> {
    if (this.parsed) return this.parsed;

    const strategy = ProtocolStrategyFactory.getStrategy(this.protocol);
    this.parsed = strategy.parseResponse(this.buffer, config);

    return this.parsed;
  }

  /**
   * è·å–è§£æç»“æœ
   */
  getParsedResult(): ParsedResult | undefined {
    return this.parsed;
  }

  /**
   * æ£€æŸ¥è§£ææ˜¯å¦æˆåŠŸ
   */
  isParseSuccess(): boolean {
    return this.parsed?.success === true;
  }

  // ============ å‘Šè­¦æ£€æŸ¥ ============

  /**
   * æ£€æŸ¥å‘Šè­¦
   */
  async checkAlarms(
    configs: AlarmConfig[],
    composer: AlarmStrategyComposer
  ): Promise<AlarmInfo[]> {
    if (!this.parsed || !this.parsed.success) {
      return [];
    }

    const deviceData: DeviceData = {
      mac: this.mac,
      pid: this.pid,
      results: this.parsed.data.map((item) => ({
        name: item.name,
        value: item.value,
        unit: item.unit,
        timestamp: this.timestamp,
      })),
    };

    this.alarms = await composer.checkAll(deviceData, configs);
    return this.alarms;
  }

  /**
   * è·å–å‘Šè­¦ä¿¡æ¯
   */
  getAlarms(): AlarmInfo[] {
    return this.alarms || [];
  }

  /**
   * æ˜¯å¦æœ‰å‘Šè­¦
   */
  hasAlarms(): boolean {
    return this.alarms && this.alarms.length > 0;
  }

  /**
   * è·å–ä¸¥é‡å‘Šè­¦
   */
  getCriticalAlarms(): AlarmInfo[] {
    return this.getAlarms().filter((a) => a.severity === 'critical');
  }

  // ============ æ•°æ®æå– ============

  /**
   * æå–æŒ‡å®šå­—æ®µå€¼
   */
  getFieldValue(fieldName: string): number | string | undefined {
    if (!this.parsed || !this.parsed.success) return undefined;

    const field = this.parsed.data.find((item) => item.name === fieldName);
    return field?.value;
  }

  /**
   * æå–æ‰€æœ‰å­—æ®µå
   */
  getFieldNames(): string[] {
    if (!this.parsed || !this.parsed.success) return [];

    return this.parsed.data.map((item) => item.name);
  }

  /**
   * æå–å‘Šè­¦å­—æ®µ
   */
  getAlarmFields(): Array<{ name: string; value: number | string }> {
    if (!this.parsed || !this.parsed.success) return [];

    return this.parsed.data
      .filter((item) => item.alarm)
      .map((item) => ({
        name: item.name,
        value: item.value,
      }));
  }

  // ============ åºåˆ—åŒ– ============

  /**
   * è½¬æ¢ä¸ºå­˜å‚¨æ ¼å¼
   */
  toStorage() {
    return {
      mac: this.mac,
      pid: this.pid,
      protocol: this.protocol,
      buffer: this.buffer.toString('hex'),
      parsed: this.parsed,
      alarms: this.alarms,
      timestamp: this.timestamp,
    };
  }

  /**
   * è½¬æ¢ä¸º JSON
   */
  toJSON() {
    return {
      mac: this.mac,
      pid: this.pid,
      protocol: this.protocol,
      bufferHex: this.buffer.toString('hex'),
      parsed: this.parsed,
      alarms: this.alarms,
      timestamp: this.timestamp,
      hasAlarms: this.hasAlarms(),
      criticalAlarmsCount: this.getCriticalAlarms().length,
    };
  }
}
```

### 3.4 Protocol å®ä½“

```typescript
/**
 * åè®®å®ä½“
 * è´Ÿè´£åè®®å®šä¹‰ã€æŒ‡ä»¤ç”Ÿæˆã€ç­–ç•¥ç®¡ç†
 */
export class Protocol {
  id: string;
  name: string;
  type: 'modbus_rtu' | 'utf8' | 'pesiv_card' | 'custom';
  version: string;

  // æŒ‡ä»¤å®šä¹‰
  instructions: ProtocolInstruction[];

  // å¸¸é‡å®šä¹‰
  constants: Record<string, any>;

  // è‡ªå®šä¹‰è„šæœ¬ï¼ˆä»… custom ç±»å‹ï¼‰
  instructionScript?: string;
  parseScript?: string;

  // å…ƒæ•°æ®
  createdAt: Date;
  updatedAt: Date;

  constructor(data: Partial<Protocol>) {
    Object.assign(this, {
      instructions: [],
      constants: {},
      createdAt: new Date(),
      updatedAt: new Date(),
      ...data,
    });
  }

  // ============ æŒ‡ä»¤ç®¡ç† ============

  /**
   * æ·»åŠ æŒ‡ä»¤
   */
  addInstruction(instruction: ProtocolInstruction) {
    this.instructions.push(instruction);
    this.updatedAt = new Date();
  }

  /**
   * æŸ¥æ‰¾æŒ‡ä»¤
   */
  findInstruction(name: string): ProtocolInstruction | undefined {
    return this.instructions.find((inst) => inst.name === name);
  }

  /**
   * è·å–æ‰€æœ‰æŒ‡ä»¤åç§°
   */
  getInstructionNames(): string[] {
    return this.instructions.map((inst) => inst.name);
  }

  // ============ ç­–ç•¥ç®¡ç† ============

  /**
   * è·å–åè®®ç­–ç•¥
   */
  getStrategy(): ProtocolStrategy {
    if (this.type === 'custom') {
      return new CustomScriptStrategy({
        instructionScript: this.instructionScript,
        parseScript: this.parseScript,
      });
    }

    return ProtocolStrategyFactory.getStrategy(this.type);
  }

  /**
   * ç”ŸæˆæŒ‡ä»¤
   */
  generateInstruction(
    instructName: string,
    pid: number,
    config?: any
  ): Buffer | string {
    const instruction = this.findInstruction(instructName);
    if (!instruction) {
      throw new Error(`Instruction not found: ${instructName}`);
    }

    const strategy = this.getStrategy();
    return strategy.generateInstruction({
      pid,
      instructName,
      ...instruction.params,
      ...config,
    });
  }

  /**
   * è§£æå“åº”
   */
  parseResponse(buffer: Buffer): ParsedResult {
    const strategy = this.getStrategy();
    return strategy.parseResponse(buffer, {
      protocol: this.type,
      constants: this.constants,
    });
  }

  // ============ éªŒè¯ ============

  /**
   * éªŒè¯åè®®å®šä¹‰
   */
  validate(): string[] {
    const errors: string[] = [];

    if (!this.id || this.id.length === 0) {
      errors.push('Protocol ID is required');
    }

    if (!this.name || this.name.length === 0) {
      errors.push('Protocol name is required');
    }

    if (!['modbus_rtu', 'utf8', 'pesiv_card', 'custom'].includes(this.type)) {
      errors.push('Invalid protocol type');
    }

    if (this.type === 'custom') {
      if (!this.instructionScript || !this.parseScript) {
        errors.push('Custom protocol requires instruction and parse scripts');
      }
    }

    if (this.instructions.length === 0) {
      errors.push('At least one instruction is required');
    }

    return errors;
  }

  // ============ åºåˆ—åŒ– ============

  /**
   * è½¬æ¢ä¸º JSON
   */
  toJSON() {
    return {
      id: this.id,
      name: this.name,
      type: this.type,
      version: this.version,
      instructions: this.instructions,
      constants: this.constants,
      instructionScript: this.instructionScript,
      parseScript: this.parseScript,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }
}

/**
 * åè®®æŒ‡ä»¤å®šä¹‰
 */
export interface ProtocolInstruction {
  name: string;
  description: string;
  params: Record<string, any>;
  response: {
    format: string;
    fields: Array<{
      name: string;
      type: string;
      unit?: string;
    }>;
  };
}
```

### 3.5 Alarm å®ä½“

```typescript
/**
 * å‘Šè­¦å®ä½“
 * è´Ÿè´£å‘Šè­¦æ•°æ®ç®¡ç†ã€æ ¼å¼åŒ–ã€å¤šæ¸ é“æ¨é€
 */
export class Alarm {
  id?: string;
  type: string;
  severity: 'info' | 'warning' | 'critical';
  message: string;

  // å‘Šè­¦æº
  mac: string;
  pid: number;
  fieldName?: string;

  // å‘Šè­¦æ•°æ®
  data: Record<string, any>;

  // çŠ¶æ€
  status: 'pending' | 'sent' | 'acknowledged' | 'resolved';

  // æ—¶é—´æˆ³
  timestamp: Date;
  sentAt?: Date;
  acknowledgedAt?: Date;
  resolvedAt?: Date;

  constructor(info: AlarmInfo & { mac: string; pid: number }) {
    this.type = info.type;
    this.severity = info.severity;
    this.message = info.message;
    this.mac = info.mac;
    this.pid = info.pid;
    this.fieldName = info.data.fieldName;
    this.data = info.data;
    this.status = 'pending';
    this.timestamp = info.timestamp;
  }

  // ============ çŠ¶æ€ç®¡ç† ============

  /**
   * æ ‡è®°ä¸ºå·²å‘é€
   */
  markAsSent() {
    this.status = 'sent';
    this.sentAt = new Date();
  }

  /**
   * æ ‡è®°ä¸ºå·²ç¡®è®¤
   */
  acknowledge() {
    this.status = 'acknowledged';
    this.acknowledgedAt = new Date();
  }

  /**
   * æ ‡è®°ä¸ºå·²è§£å†³
   */
  resolve() {
    this.status = 'resolved';
    this.resolvedAt = new Date();
  }

  /**
   * æ˜¯å¦å·²è§£å†³
   */
  isResolved(): boolean {
    return this.status === 'resolved';
  }

  /**
   * æ˜¯å¦éœ€è¦å‘é€
   */
  shouldSend(): boolean {
    return this.status === 'pending';
  }

  // ============ æ¶ˆæ¯æ ¼å¼åŒ– ============

  /**
   * æ ¼å¼åŒ–ä¸ºå¾®ä¿¡æ¨¡æ¿æ¶ˆæ¯
   */
  toWeChatTemplate(templateId: string) {
    return {
      template_id: templateId,
      data: {
        first: {
          value: this.message,
          color: this.getSeverityColor(),
        },
        keyword1: { value: this.mac },
        keyword2: { value: this.fieldName || 'N/A' },
        keyword3: { value: this.timestamp.toLocaleString('zh-CN') },
        keyword4: { value: this.severity.toUpperCase() },
        remark: { value: 'è¯·åŠæ—¶å¤„ç†' },
      },
    };
  }

  /**
   * æ ¼å¼åŒ–ä¸ºçŸ­ä¿¡å†…å®¹
   */
  toSmsMessage(): string {
    return `ã€å‘Šè­¦ã€‘${this.message}ã€‚è®¾å¤‡:${this.mac}ï¼Œæ—¶é—´:${this.timestamp.toLocaleString('zh-CN')}`;
  }

  /**
   * æ ¼å¼åŒ–ä¸ºé‚®ä»¶ HTML
   */
  toEmailHtml(): string {
    const color = this.getSeverityColor();

    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="UTF-8">
        <style>
          body { font-family: Arial, sans-serif; line-height: 1.6; }
          .container { max-width: 600px; margin: 0 auto; padding: 20px; }
          .header {
            background: ${color};
            color: white;
            padding: 20px;
            border-radius: 5px 5px 0 0;
          }
          .content {
            border: 1px solid #ddd;
            padding: 20px;
            border-radius: 0 0 5px 5px;
            background: #f9f9f9;
          }
          .field {
            margin: 15px 0;
            padding: 10px;
            background: white;
            border-left: 3px solid ${color};
          }
          .label { font-weight: bold; color: #555; margin-right: 10px; }
          .value { color: #000; }
          .footer {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
            color: #888;
            font-size: 12px;
          }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h2>ğŸš¨ è®¾å¤‡å‘Šè­¦é€šçŸ¥</h2>
            <p style="margin: 5px 0;">çº§åˆ«ï¼š${this.severity.toUpperCase()}</p>
          </div>
          <div class="content">
            <div class="field">
              <span class="label">å‘Šè­¦ç±»å‹ï¼š</span>
              <span class="value">${this.type}</span>
            </div>
            <div class="field">
              <span class="label">å‘Šè­¦å†…å®¹ï¼š</span>
              <span class="value">${this.message}</span>
            </div>
            <div class="field">
              <span class="label">è®¾å¤‡ MACï¼š</span>
              <span class="value">${this.mac}</span>
            </div>
            <div class="field">
              <span class="label">è®¾å¤‡ PIDï¼š</span>
              <span class="value">${this.pid}</span>
            </div>
            ${this.fieldName ? `
            <div class="field">
              <span class="label">å­—æ®µåç§°ï¼š</span>
              <span class="value">${this.fieldName}</span>
            </div>
            ` : ''}
            <div class="field">
              <span class="label">å‘Šè­¦æ—¶é—´ï¼š</span>
              <span class="value">${this.timestamp.toLocaleString('zh-CN')}</span>
            </div>
            <div class="field">
              <span class="label">è¯¦ç»†æ•°æ®ï¼š</span>
              <pre class="value">${JSON.stringify(this.data, null, 2)}</pre>
            </div>
          </div>
          <div class="footer">
            <p>æ­¤é‚®ä»¶ç”± UART æœåŠ¡å™¨è‡ªåŠ¨å‘é€ï¼Œè¯·å‹¿å›å¤ã€‚</p>
            <p>å¦‚æœ‰ç–‘é—®ï¼Œè¯·è”ç³»ç³»ç»Ÿç®¡ç†å‘˜ã€‚</p>
          </div>
        </div>
      </body>
      </html>
    `;
  }

  /**
   * æ ¼å¼åŒ–ä¸ºé’‰é’‰ Markdown
   */
  toDingTalkMarkdown(): string {
    const emoji = this.getSeverityEmoji();

    return `
## ${emoji} è®¾å¤‡å‘Šè­¦é€šçŸ¥

**å‘Šè­¦ç±»å‹ï¼š** ${this.type}

**å‘Šè­¦çº§åˆ«ï¼š** <font color="${this.getSeverityColor()}">${this.severity.toUpperCase()}</font>

**å‘Šè­¦å†…å®¹ï¼š** ${this.message}

---

**è®¾å¤‡ä¿¡æ¯ï¼š**
- MAC: \`${this.mac}\`
- PID: \`${this.pid}\`
${this.fieldName ? `- å­—æ®µ: \`${this.fieldName}\`` : ''}

**å‘Šè­¦æ—¶é—´ï¼š** ${this.timestamp.toLocaleString('zh-CN')}

---

**è¯¦ç»†æ•°æ®ï¼š**
\`\`\`json
${JSON.stringify(this.data, null, 2)}
\`\`\`

> ğŸ“¢ è¯·åŠæ—¶å¤„ç†å‘Šè­¦
    `.trim();
  }

  // ============ å·¥å…·æ–¹æ³• ============

  /**
   * è·å–ä¸¥é‡ç¨‹åº¦é¢œè‰²
   */
  private getSeverityColor(): string {
    const colors = {
      info: '#00CC00',
      warning: '#FF9900',
      critical: '#FF0000',
    };
    return colors[this.severity];
  }

  /**
   * è·å–ä¸¥é‡ç¨‹åº¦ Emoji
   */
  private getSeverityEmoji(): string {
    const emojis = {
      info: 'â„¹ï¸',
      warning: 'âš ï¸',
      critical: 'ğŸš¨',
    };
    return emojis[this.severity];
  }

  /**
   * è·å–å‘Šè­¦æŒç»­æ—¶é—´ï¼ˆç§’ï¼‰
   */
  getDuration(): number {
    const end = this.resolvedAt || new Date();
    return Math.floor((end.getTime() - this.timestamp.getTime()) / 1000);
  }

  // ============ åºåˆ—åŒ– ============

  /**
   * è½¬æ¢ä¸º JSON
   */
  toJSON() {
    return {
      id: this.id,
      type: this.type,
      severity: this.severity,
      message: this.message,
      mac: this.mac,
      pid: this.pid,
      fieldName: this.fieldName,
      data: this.data,
      status: this.status,
      timestamp: this.timestamp,
      sentAt: this.sentAt,
      acknowledgedAt: this.acknowledgedAt,
      resolvedAt: this.resolvedAt,
      duration: this.getDuration(),
    };
  }

  /**
   * è½¬æ¢ä¸ºç®€åŒ– JSON
   */
  toSimpleJSON() {
    return {
      id: this.id,
      type: this.type,
      severity: this.severity,
      message: this.message,
      mac: this.mac,
      status: this.status,
      timestamp: this.timestamp,
    };
  }
}
```

### 3.6 User å®ä½“

```typescript
/**
 * ç”¨æˆ·å®ä½“
 * è´Ÿè´£ç”¨æˆ·æƒé™ã€ç»ˆç«¯ç»‘å®šã€é€šçŸ¥åå¥½ç®¡ç†
 */
export class User {
  id: string;
  username: string;
  password: string;
  name: string;
  userGroup: string;

  // è”ç³»æ–¹å¼
  mail?: string;
  tel?: string;

  // å¾®ä¿¡ä¿¡æ¯
  wxId?: string;
  openid?: string;

  // ç»ˆç«¯ç»‘å®š
  bindTerminals: string[]; // MAC åœ°å€åˆ—è¡¨

  // é€šçŸ¥åå¥½
  notificationPreferences: {
    wechat: boolean;
    sms: boolean;
    email: boolean;
    dingtalk: boolean;
  };

  // æ—¶é—´æˆ³
  createdAt: Date;
  updatedAt: Date;

  constructor(data: Partial<User>) {
    Object.assign(this, {
      bindTerminals: [],
      notificationPreferences: {
        wechat: true,
        sms: false,
        email: false,
        dingtalk: false,
      },
      createdAt: new Date(),
      updatedAt: new Date(),
      ...data,
    });
  }

  // ============ æƒé™ç®¡ç† ============

  /**
   * æ£€æŸ¥æ˜¯å¦æ˜¯ç®¡ç†å‘˜
   */
  isAdmin(): boolean {
    return this.userGroup === 'admin';
  }

  /**
   * æ£€æŸ¥æ˜¯å¦æœ‰ç»ˆç«¯è®¿é—®æƒé™
   */
  hasTerminalAccess(mac: string): boolean {
    if (this.isAdmin()) return true;
    return this.bindTerminals.includes(mac);
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å¯ä»¥ç®¡ç†åè®®
   */
  canManageProtocols(): boolean {
    return this.isAdmin();
  }

  /**
   * æ£€æŸ¥æ˜¯å¦å¯ä»¥ç®¡ç†ç”¨æˆ·
   */
  canManageUsers(): boolean {
    return this.isAdmin();
  }

  // ============ ç»ˆç«¯ç»‘å®š ============

  /**
   * ç»‘å®šç»ˆç«¯
   */
  bindTerminal(mac: string): boolean {
    if (this.bindTerminals.includes(mac)) return false;

    this.bindTerminals.push(mac);
    this.updatedAt = new Date();
    return true;
  }

  /**
   * è§£ç»‘ç»ˆç«¯
   */
  unbindTerminal(mac: string): boolean {
    const index = this.bindTerminals.indexOf(mac);
    if (index === -1) return false;

    this.bindTerminals.splice(index, 1);
    this.updatedAt = new Date();
    return true;
  }

  /**
   * æ‰¹é‡ç»‘å®šç»ˆç«¯
   */
  bindMultipleTerminals(macs: string[]) {
    const newMacs = macs.filter((mac) => !this.bindTerminals.includes(mac));
    this.bindTerminals.push(...newMacs);
    this.updatedAt = new Date();
    return newMacs.length;
  }

  /**
   * è·å–ç»‘å®šçš„ç»ˆç«¯åˆ—è¡¨
   */
  getBindTerminals(): string[] {
    return [...this.bindTerminals];
  }

  /**
   * æ¸…ç©ºç»ˆç«¯ç»‘å®š
   */
  clearTerminalBindings() {
    this.bindTerminals = [];
    this.updatedAt = new Date();
  }

  // ============ é€šçŸ¥ç®¡ç† ============

  /**
   * æ›´æ–°é€šçŸ¥åå¥½
   */
  updateNotificationPreferences(preferences: Partial<User['notificationPreferences']>) {
    Object.assign(this.notificationPreferences, preferences);
    this.updatedAt = new Date();
  }

  /**
   * å¯ç”¨é€šçŸ¥æ¸ é“
   */
  enableNotification(channel: keyof User['notificationPreferences']) {
    this.notificationPreferences[channel] = true;
    this.updatedAt = new Date();
  }

  /**
   * ç¦ç”¨é€šçŸ¥æ¸ é“
   */
  disableNotification(channel: keyof User['notificationPreferences']) {
    this.notificationPreferences[channel] = false;
    this.updatedAt = new Date();
  }

  /**
   * è·å–å¯ç”¨çš„é€šçŸ¥æ¸ é“
   */
  getEnabledNotificationChannels(): string[] {
    return Object.entries(this.notificationPreferences)
      .filter(([_, enabled]) => enabled)
      .map(([channel]) => channel);
  }

  /**
   * è·å–é€šçŸ¥æ¥æ”¶è€…åˆ—è¡¨
   */
  getNotificationRecipients(): Recipient[] {
    const recipients: Recipient[] = [];

    if (this.notificationPreferences.wechat && this.openid) {
      recipients.push({ type: 'wechat', target: this.openid });
    }

    if (this.notificationPreferences.sms && this.tel) {
      recipients.push({ type: 'sms', target: this.tel });
    }

    if (this.notificationPreferences.email && this.mail) {
      recipients.push({ type: 'email', target: this.mail });
    }

    // DingTalk webhook éœ€è¦ä»é…ç½®ä¸­è·å–
    // if (this.notificationPreferences.dingtalk) {
    //   recipients.push({ type: 'dingtalk', target: webhookUrl });
    // }

    return recipients;
  }

  // ============ è”ç³»æ–¹å¼éªŒè¯ ============

  /**
   * éªŒè¯é‚®ç®±æ ¼å¼
   */
  static isValidEmail(email: string): boolean {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }

  /**
   * éªŒè¯æ‰‹æœºå·æ ¼å¼
   */
  static isValidPhone(phone: string): boolean {
    return /^1[3-9]\d{9}$/.test(phone);
  }

  /**
   * æ›´æ–°é‚®ç®±
   */
  updateEmail(email: string): boolean {
    if (!User.isValidEmail(email)) return false;
    this.mail = email;
    this.updatedAt = new Date();
    return true;
  }

  /**
   * æ›´æ–°æ‰‹æœºå·
   */
  updatePhone(phone: string): boolean {
    if (!User.isValidPhone(phone)) return false;
    this.tel = phone;
    this.updatedAt = new Date();
    return true;
  }

  // ============ å¯†ç ç®¡ç† ============

  /**
   * éªŒè¯å¯†ç ï¼ˆéœ€è¦é…åˆåŠ å¯†åº“ï¼‰
   */
  async verifyPassword(password: string): Promise<boolean> {
    // ä½¿ç”¨ bcrypt æˆ–å…¶ä»–åŠ å¯†åº“
    // return await bcrypt.compare(password, this.password);
    return this.password === password; // ä¸´æ—¶å®ç°
  }

  /**
   * è®¾ç½®å¯†ç ï¼ˆéœ€è¦é…åˆåŠ å¯†åº“ï¼‰
   */
  async setPassword(password: string) {
    // this.password = await bcrypt.hash(password, 10);
    this.password = password; // ä¸´æ—¶å®ç°
    this.updatedAt = new Date();
  }

  // ============ éªŒè¯ ============

  /**
   * éªŒè¯ç”¨æˆ·æ•°æ®
   */
  validate(): string[] {
    const errors: string[] = [];

    if (!this.username || this.username.length < 3) {
      errors.push('Username must be at least 3 characters');
    }

    if (!this.password || this.password.length < 6) {
      errors.push('Password must be at least 6 characters');
    }

    if (!this.name || this.name.length === 0) {
      errors.push('Name is required');
    }

    if (this.mail && !User.isValidEmail(this.mail)) {
      errors.push('Invalid email format');
    }

    if (this.tel && !User.isValidPhone(this.tel)) {
      errors.push('Invalid phone format');
    }

    return errors;
  }

  // ============ åºåˆ—åŒ– ============

  /**
   * è½¬æ¢ä¸º JSONï¼ˆæ’é™¤æ•æ„Ÿä¿¡æ¯ï¼‰
   */
  toJSON() {
    return {
      id: this.id,
      username: this.username,
      name: this.name,
      userGroup: this.userGroup,
      mail: this.mail,
      tel: this.tel,
      wxId: this.wxId,
      bindTerminals: this.bindTerminals,
      notificationPreferences: this.notificationPreferences,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt,
    };
  }

  /**
   * è½¬æ¢ä¸ºå®Œæ•´ JSONï¼ˆåŒ…å«æ‰€æœ‰ä¿¡æ¯ï¼Œä»…ç®¡ç†å‘˜å¯è§ï¼‰
   */
  toFullJSON() {
    return {
      ...this.toJSON(),
      openid: this.openid,
      password: '***', // ä¸æš´éœ²çœŸå®å¯†ç 
    };
  }
}
```

---

## 4. æœ€ä½³å®è·µ

### 4.1 ORM ä½¿ç”¨å»ºè®®

1. **ç´¢å¼•ä¼˜åŒ–**
   - åœ¨ Repository åˆå§‹åŒ–æ—¶åˆ›å»ºç´¢å¼•
   - å¸¸ç”¨æŸ¥è¯¢å­—æ®µæ·»åŠ å•å­—æ®µç´¢å¼•
   - å¤åˆæŸ¥è¯¢æ·»åŠ å¤åˆç´¢å¼•
   - å®šæœŸåˆ†ææ…¢æŸ¥è¯¢æ—¥å¿—

2. **æ‰¹é‡æ“ä½œ**
   - ä½¿ç”¨ `bulkWrite` æ›¿ä»£å¤šæ¬¡å•ç‹¬æ“ä½œ
   - æ‰¹é‡æ“ä½œä½¿ç”¨äº‹åŠ¡ä¿è¯ä¸€è‡´æ€§
   - æ§åˆ¶æ‰¹é‡å¤§å°ï¼ˆå»ºè®® 100-1000 æ¡ï¼‰

3. **æŠ•å½±ä¼˜åŒ–**
   - åªæŸ¥è¯¢éœ€è¦çš„å­—æ®µ
   - ä½¿ç”¨ `.project()` å‡å°‘æ•°æ®ä¼ è¾“

4. **ç¼“å­˜ç­–ç•¥**
   - çƒ­ç‚¹æ•°æ®ä½¿ç”¨ Redis ç¼“å­˜
   - è®¾ç½®åˆç†çš„ TTL
   - ç¼“å­˜å¤±æ•ˆç­–ç•¥ï¼šå†™å…¥æ—¶æ›´æ–°ç¼“å­˜

### 4.2 ç­–ç•¥æ¨¡å¼æœ€ä½³å®è·µ

1. **ç­–ç•¥æ³¨å†Œ**
   - åº”ç”¨å¯åŠ¨æ—¶æ³¨å†Œæ‰€æœ‰ç­–ç•¥
   - ä»æ•°æ®åº“åŠ è½½è‡ªå®šä¹‰ç­–ç•¥
   - æ”¯æŒçƒ­åŠ è½½æ–°ç­–ç•¥

2. **ç­–ç•¥ç¼“å­˜**
   - ç¼“å­˜ç­–ç•¥å®ä¾‹é¿å…é‡å¤åˆ›å»º
   - ä½¿ç”¨ WeakMap å­˜å‚¨ç­–ç•¥é¿å…å†…å­˜æ³„æ¼

3. **é”™è¯¯å¤„ç†**
   - ç­–ç•¥æ‰§è¡Œå¤±è´¥åº”æœ‰é™çº§æ–¹æ¡ˆ
   - è®°å½•è¯¦ç»†é”™è¯¯æ—¥å¿—
   - ä¸è¦è®©å•ä¸ªç­–ç•¥å¤±è´¥å½±å“æ•´ä½“æµç¨‹

4. **æ€§èƒ½ä¼˜åŒ–**
   - é¢„ç¼–è¯‘è„šæœ¬ï¼ˆè‡ªå®šä¹‰ç­–ç•¥ï¼‰
   - ç¼“å­˜è®¡ç®—ç»“æœ
   - å¼‚æ­¥æ‰§è¡Œéå…³é”®ç­–ç•¥

### 4.3 å®ä½“ç±»æœ€ä½³å®è·µ

1. **èŒè´£å•ä¸€**
   - æ¯ä¸ªå®ä½“åªè´Ÿè´£è‡ªå·±çš„é¢†åŸŸé€»è¾‘
   - ä¸è¦åœ¨å®ä½“ä¸­ç›´æ¥è°ƒç”¨å¤–éƒ¨æœåŠ¡
   - å¤æ‚ä¸šåŠ¡é€»è¾‘æ”¾åœ¨ Service å±‚

2. **ä¸å¯å˜æ€§**
   - å…³é”®æ•°æ®ä½¿ç”¨ readonly
   - æä¾›æ–¹æ³•ä¿®æ”¹çŠ¶æ€è€Œä¸æ˜¯ç›´æ¥èµ‹å€¼
   - çŠ¶æ€å˜æ›´æ—¶æ›´æ–° updatedAt

3. **éªŒè¯**
   - æ„é€ å‡½æ•°ä¸­è¿›è¡ŒåŸºæœ¬éªŒè¯
   - æä¾› validate() æ–¹æ³•è¿›è¡Œå®Œæ•´éªŒè¯
   - çŠ¶æ€å˜æ›´æ—¶éªŒè¯æ•°æ®åˆæ³•æ€§

4. **åºåˆ—åŒ–**
   - æä¾› toJSON() ç”¨äº API å“åº”
   - æä¾› toStorage() ç”¨äºæ•°æ®åº“å­˜å‚¨
   - æ•æ„Ÿä¿¡æ¯ä¸è¦åºåˆ—åŒ–

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0.0
**æœ€åæ›´æ–°**: 2024-12-16
**ç»´æŠ¤è€…**: å¼€å‘å›¢é˜Ÿ
