# Bun + Fastify ä»£ç å®ç°ç¤ºä¾‹æ–‡æ¡£

**ç‰ˆæœ¬**: 1.0
**æ—¥æœŸ**: 2025-12-16
**çŠ¶æ€**: å¾…å®¡æ ¸

---

## æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£æä¾›å®Œæ•´çš„ä»£ç å®ç°ç¤ºä¾‹ï¼Œæ¶µç›–è£…é¥°å™¨ç³»ç»Ÿã€queryData ä¼˜åŒ–ã€Worker æ± ã€æ‰¹é‡å†™å…¥ç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚æ‰€æœ‰ä»£ç å‡å¯ç›´æ¥ä½¿ç”¨æˆ–æ ¹æ®å®é™…éœ€æ±‚è°ƒæ•´ã€‚

---

## 1. é¡¹ç›®åˆå§‹åŒ–

### 1.1 package.json

```json
{
  "name": "bun-fastify-uart-server",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "bun run --watch src/server.ts",
    "start": "bun run src/server.ts",
    "test": "bun test",
    "build": "bun build src/server.ts --outdir dist --target bun"
  },
  "dependencies": {
    "fastify": "^5.1.0",
    "@fastify/cors": "^10.0.1",
    "@fastify/jwt": "^9.0.1",
    "@fastify/multipart": "^9.0.1",
    "socket.io": "^4.8.1",
    "mongoose": "^8.8.4",
    "ioredis": "^5.4.1",
    "joi": "^17.13.3",
    "pino": "^9.5.0",
    "bcryptjs": "^2.4.3",
    "class-validator": "^0.14.1"
  },
  "devDependencies": {
    "@types/node": "^22.10.2",
    "@types/bcryptjs": "^2.4.6",
    "typescript": "^5.7.2"
  }
}
```

### 1.2 tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "lib": ["ESNext"],
    "types": ["bun-types"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "allowSyntheticDefaultImports": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "tests"]
}
```

### 1.3 .env.example

```bash
# Server
NODE_ENV=development
PORT=9001
HOST=0.0.0.0

# MongoDB
MONGODB_URI=mongodb://localhost:27017/UartServer
MONGODB_MAX_POOL_SIZE=100

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
REDIS_DB=0

# JWT
JWT_SECRET=your-secret-key-change-this-in-production
JWT_EXPIRES_IN=7d

# Worker Pool
WORKER_COUNT=4

# Batch Write
LOG_BUFFER_SIZE=1000
LOG_FLUSH_INTERVAL=1000
STATE_BUFFER_SIZE=500
STATE_FLUSH_INTERVAL=500

# External Services
ALIOSS_ID=
ALIOSS_SECRET=
ALIOSS_BUCKET=
ALIOSS_ENDPOINT=
```

---

## 2. è£…é¥°å™¨ç³»ç»Ÿå®ç°

### 2.1 å…ƒæ•°æ®ç®¡ç†

```typescript
// src/decorators/metadata.ts

export interface RouteMetadata {
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  path: string;
  handler: string;
  middlewares?: Function[];
  schema?: any;
}

export interface ParamMetadata {
  index: number;
  type: 'body' | 'query' | 'params' | 'headers' | 'user';
  key?: string;
  transform?: (value: any) => any;
}

export interface RoleMetadata {
  roles: string[];
}

// å…¨å±€å…ƒæ•°æ®å­˜å‚¨
export const ROUTE_METADATA = new Map<Function, RouteMetadata[]>();
export const PARAM_METADATA = new Map<Function, Map<string, ParamMetadata[]>>();
export const ROLE_METADATA = new Map<Function, Map<string, RoleMetadata>>();

// è¾…åŠ©å‡½æ•°
export function getRoutes(target: Function): RouteMetadata[] {
  return ROUTE_METADATA.get(target) || [];
}

export function getParams(target: Function, methodName: string): ParamMetadata[] {
  const methods = PARAM_METADATA.get(target);
  return methods?.get(methodName) || [];
}

export function getRoles(target: Function, methodName: string): string[] {
  const methods = ROLE_METADATA.get(target);
  return methods?.get(methodName)?.roles || [];
}
```

### 2.2 Controller è£…é¥°å™¨

```typescript
// src/decorators/controller.decorator.ts

import 'reflect-metadata';

const CONTROLLER_METADATA_KEY = 'controller:basePath';

export function Controller(basePath: string = '') {
  return function (target: Function) {
    Reflect.defineMetadata(CONTROLLER_METADATA_KEY, basePath, target);
  };
}

export function getBasePath(target: Function): string {
  return Reflect.getMetadata(CONTROLLER_METADATA_KEY, target) || '';
}
```

### 2.3 Route è£…é¥°å™¨

```typescript
// src/decorators/route.decorator.ts

import { ROUTE_METADATA, RouteMetadata } from './metadata';

function createRouteDecorator(method: RouteMetadata['method']) {
  return function (path: string) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
      const constructor = target.constructor;

      if (!ROUTE_METADATA.has(constructor)) {
        ROUTE_METADATA.set(constructor, []);
      }

      const routes = ROUTE_METADATA.get(constructor)!;
      routes.push({
        method,
        path,
        handler: propertyKey
      });

      return descriptor;
    };
  };
}

export const Get = createRouteDecorator('GET');
export const Post = createRouteDecorator('POST');
export const Put = createRouteDecorator('PUT');
export const Delete = createRouteDecorator('DELETE');
export const Patch = createRouteDecorator('PATCH');
```

### 2.4 Parameter è£…é¥°å™¨

```typescript
// src/decorators/param.decorator.ts

import { PARAM_METADATA, ParamMetadata } from './metadata';

function createParamDecorator(type: ParamMetadata['type'], key?: string) {
  return function (target: any, propertyKey: string, parameterIndex: number) {
    const constructor = target.constructor;

    if (!PARAM_METADATA.has(constructor)) {
      PARAM_METADATA.set(constructor, new Map());
    }

    const methods = PARAM_METADATA.get(constructor)!;
    if (!methods.has(propertyKey)) {
      methods.set(propertyKey, []);
    }

    const params = methods.get(propertyKey)!;
    params.push({
      index: parameterIndex,
      type,
      key
    });
  };
}

export const Body = (key?: string) => createParamDecorator('body', key);
export const Query = (key?: string) => createParamDecorator('query', key);
export const Params = (key?: string) => createParamDecorator('params', key);
export const Headers = (key?: string) => createParamDecorator('headers', key);

// è‡ªå®šä¹‰ User è£…é¥°å™¨ï¼ˆä»è¯·æ±‚ä¸­æå–è®¤è¯ç”¨æˆ·ï¼‰
export const User = () => createParamDecorator('user');
```

### 2.5 Auth è£…é¥°å™¨

```typescript
// src/decorators/auth.decorator.ts

import { ROLE_METADATA } from './metadata';

export enum RoleType {
  ROOT = 'root',
  ADMIN = 'admin',
  USER = 'user',
  GUEST = 'guest'
}

export function Role(...roles: RoleType[]) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const constructor = target.constructor;

    if (!ROLE_METADATA.has(constructor)) {
      ROLE_METADATA.set(constructor, new Map());
    }

    const methods = ROLE_METADATA.get(constructor)!;
    methods.set(propertyKey, { roles });

    return descriptor;
  };
}

export function Auth() {
  return Role(RoleType.USER, RoleType.ADMIN, RoleType.ROOT);
}
```

### 2.6 Validate è£…é¥°å™¨

```typescript
// src/decorators/validate.decorator.ts

import Joi from 'joi';

const VALIDATION_METADATA_KEY = 'validation:schema';

export function Validate(schema: Joi.ObjectSchema) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    Reflect.defineMetadata(VALIDATION_METADATA_KEY, schema, target, propertyKey);
    return descriptor;
  };
}

export function getValidationSchema(target: any, propertyKey: string): Joi.ObjectSchema | undefined {
  return Reflect.getMetadata(VALIDATION_METADATA_KEY, target, propertyKey);
}
```

---

## 3. è·¯ç”±åŠ è½½ç³»ç»Ÿ

### 3.1 Service Container

```typescript
// src/core/service-container.ts

export class ServiceContainer {
  private services = new Map<string, any>();

  register(name: string, service: any) {
    this.services.set(name, service);
  }

  get<T = any>(name: string): T {
    const service = this.services.get(name);
    if (!service) {
      throw new Error(`Service ${name} not found`);
    }
    return service;
  }

  has(name: string): boolean {
    return this.services.has(name);
  }
}
```

### 3.2 Route Loader

```typescript
// src/core/route-loader.ts

import { FastifyInstance, FastifyRequest, FastifyReply } from 'fastify';
import { getBasePath } from '../decorators/controller.decorator';
import { getRoutes, getParams, getRoles } from '../decorators/metadata';
import { getValidationSchema } from '../decorators/validate.decorator';
import { ServiceContainer } from './service-container';

export class RouteLoader {
  constructor(
    private app: FastifyInstance,
    private services: ServiceContainer
  ) {}

  loadControllers(controllers: Function[]) {
    for (const ControllerClass of controllers) {
      this.loadController(ControllerClass);
    }
  }

  private loadController(ControllerClass: Function) {
    const basePath = getBasePath(ControllerClass);
    const routes = getRoutes(ControllerClass);

    // åˆ›å»ºæ§åˆ¶å™¨å®ä¾‹
    const instance = new (ControllerClass as any)(this.services);

    for (const route of routes) {
      const fullPath = basePath + route.path;
      const handler = this.createHandler(instance, route.handler, ControllerClass);

      // æ³¨å†Œè·¯ç”±
      const method = route.method.toLowerCase() as 'get' | 'post' | 'put' | 'delete';
      this.app[method](fullPath, handler);

      console.log(`[Route] ${route.method} ${fullPath} -> ${ControllerClass.name}.${route.handler}`);
    }
  }

  private createHandler(instance: any, methodName: string, ControllerClass: Function) {
    return async (request: FastifyRequest, reply: FastifyReply) => {
      try {
        // 1. è§’è‰²éªŒè¯
        const roles = getRoles(ControllerClass, methodName);
        if (roles.length > 0) {
          await this.validateRoles(request, roles);
        }

        // 2. å‚æ•°æ³¨å…¥
        const params = getParams(ControllerClass, methodName);
        const args = this.extractParams(request, reply, params);

        // 3. DTO éªŒè¯
        const schema = getValidationSchema(instance, methodName);
        if (schema && args[0]) {
          const { error } = schema.validate(args[0]);
          if (error) {
            return reply.code(400).send({
              code: 400,
              message: error.details[0].message
            });
          }
        }

        // 4. æ‰§è¡Œå¤„ç†å™¨
        const result = await instance[methodName](...args);

        // 5. å“åº”åºåˆ—åŒ–
        if (result !== undefined && result !== null) {
          if (typeof result === 'object' && 'code' in result) {
            return reply.send(result);
          }
          return reply.send({ code: 200, data: result });
        }
      } catch (error: any) {
        console.error(`[Error] ${ControllerClass.name}.${methodName}:`, error);
        return reply.code(error.statusCode || 500).send({
          code: 0,
          status: error.statusCode || 500,
          message: error.message
        });
      }
    };
  }

  private extractParams(request: FastifyRequest, reply: FastifyReply, params: any[]): any[] {
    const args: any[] = [];

    params.sort((a, b) => a.index - b.index);

    for (const param of params) {
      switch (param.type) {
        case 'body':
          args[param.index] = param.key ? (request.body as any)?.[param.key] : request.body;
          break;
        case 'query':
          args[param.index] = param.key ? (request.query as any)?.[param.key] : request.query;
          break;
        case 'params':
          args[param.index] = param.key ? (request.params as any)?.[param.key] : request.params;
          break;
        case 'headers':
          args[param.index] = param.key ? request.headers[param.key] : request.headers;
          break;
        case 'user':
          args[param.index] = (request as any).user;
          break;
      }
    }

    return args;
  }

  private async validateRoles(request: FastifyRequest, roles: string[]) {
    const user = (request as any).user;
    if (!user || !roles.includes(user.userGroup)) {
      throw { statusCode: 403, message: 'Forbidden' };
    }
  }
}
```

---

## 4. queryData API ä¼˜åŒ–å®ç°

### 4.1 ä¼˜åŒ–å‰ä»£ç ï¼ˆå‚è€ƒï¼‰

```typescript
// æ—§ä»£ç ï¼ˆMidway.jsï¼‰- ä»…ä¾›å¯¹æ¯”
@Post('/queryData')
async queryData(@Body('data') data: Uart.queryResult) {
  // âŒ ä¸²è¡Œé˜»å¡ HTTP å“åº”
  await this.terminalService.setLastRecordDevs(data.mac, data.pid);  // 20ms
  await this.parseService.queryData(data);  // 100-200ms
  return 'ok';  // æ€»è€—æ—¶: 150-300ms
}
```

### 4.2 ä¼˜åŒ–åä»£ç 

```typescript
// src/controllers/node.controller.ts

import { Controller, Post, Body } from '../decorators';
import { ServiceContainer } from '../core/service-container';

@Controller('/api/node')
export class NodeController {
  private parseSet = new Set<string>();
  private queryDataService: QueryDataService;
  private socketUserService: SocketUserService;

  constructor(private services: ServiceContainer) {
    this.queryDataService = services.get('QueryDataService');
    this.socketUserService = services.get('SocketUserService');
  }

  @Post('/queryData')
  async queryData(@Body('data') data: Uart.queryResult) {
    // 1. å¿«é€ŸéªŒè¯ï¼ˆ<1msï¼‰
    const key = `${data.mac}:${data.pid}`;
    if (this.parseSet.has(key)) {
      return { status: 'skip', reason: 'Already processing' };
    }

    // 2. æ ‡è®°å¤„ç†ä¸­
    this.parseSet.add(key);

    // 3. å¼‚æ­¥å¤„ç†ï¼ˆä¸ç­‰å¾…ï¼‰â­
    this.queryDataService.processAsync(data, key).catch(err => {
      console.error(`[QueryData] Process error: ${key}`, err);
    });

    // 4. ç«‹å³å“åº”ï¼ˆ<5msï¼‰âœ…
    return {
      status: 'ok',
      receivedAt: Date.now(),
      key
    };
  }
}
```

### 4.3 å¼‚æ­¥å¤„ç†æœåŠ¡

```typescript
// src/services/query-data.service.ts

export class QueryDataService {
  private parseSet: Set<string>;
  private lastRecordBuffer: StateUpdateBuffer;
  private logBuffer: LogBufferService;
  private workerPool: WorkerPool;
  private parseService: ParseService;
  private socketUserService: SocketUserService;

  constructor(services: ServiceContainer) {
    this.lastRecordBuffer = services.get('StateUpdateBuffer');
    this.logBuffer = services.get('LogBufferService');
    this.workerPool = services.get('WorkerPool');
    this.parseService = services.get('ParseService');
    this.socketUserService = services.get('SocketUserService');
  }

  setParseSet(parseSet: Set<string>) {
    this.parseSet = parseSet;
  }

  async processAsync(data: Uart.queryResult, key: string) {
    try {
      // 1. WebSocket æ¨é€ï¼ˆéé˜»å¡ï¼‰
      this.socketUserService.sendMacListenMessage(data.mac, {
        type: 'queryData',
        data
      });

      // 2. æ‰¹é‡ç¼“å†²çŠ¶æ€æ›´æ–°ï¼ˆ<1msï¼‰
      this.lastRecordBuffer.add(data.mac, data.pid, {
        timestamp: new Date()
      });

      // 3. åˆ†å‘åˆ° Worker æ± å¤„ç†
      const result = await this.workerPool.dispatch({
        type: 'PARSE_DEVICE_DATA',
        data
      });

      // 4. åç»­å¤„ç†ï¼ˆå‘Šè­¦æ£€æŸ¥ã€å†å²ä¿å­˜ç­‰ï¼‰
      await this.handleParseResult(data, result);

    } catch (error) {
      console.error(`[QueryData] Process failed: ${key}`, error);

      // è®°å½•é”™è¯¯æ—¥å¿—
      this.logBuffer.add('log_errors', {
        key,
        error: error.message,
        timestamp: Date.now()
      });
    } finally {
      // 10 ç§’åæ¸…é™¤æ ‡è®°
      setTimeout(() => this.parseSet.delete(key), 10000);
    }
  }

  private async handleParseResult(data: Uart.queryResult, result: any) {
    // å‘Šè­¦æ£€æŸ¥ã€æ•°æ®ä¿å­˜ç­‰é€»è¾‘
    // è¯¦ç»†å®ç°è§åŸ dev.parse.processor.ts
  }
}
```

---

## 5. Worker æ± å®ç°

### 5.1 Worker Pool Manager

```typescript
// src/workers/worker-pool.ts

export interface Task {
  taskId?: string;
  type: string;
  data: any;
}

interface PendingTask {
  resolve: (value: any) => void;
  reject: (error: Error) => void;
  createdAt: number;
}

export class WorkerPool {
  private workers: Worker[] = [];
  private taskQueue: Task[] = [];
  private pendingTasks = new Map<string, PendingTask>();
  private workerAvailability: boolean[] = [];

  constructor(workerCount: number = 4) {
    for (let i = 0; i < workerCount; i++) {
      this.createWorker(i);
    }

    // å®šæœŸæ¸…ç†è¶…æ—¶ä»»åŠ¡
    setInterval(() => this.cleanupTimeoutTasks(), 30000);
  }

  private createWorker(index: number) {
    const worker = new Worker('./parse-worker.ts');

    worker.onmessage = (event) => {
      this.handleWorkerMessage(index, event.data);
    };

    worker.onerror = (error) => {
      console.error(`[Worker ${index}] Error:`, error);
      // é‡å¯ Worker
      this.workers[index].terminate();
      this.createWorker(index);
    };

    this.workers[index] = worker;
    this.workerAvailability[index] = true;
  }

  async dispatch(task: Task): Promise<any> {
    const taskId = crypto.randomUUID();
    task.taskId = taskId;

    return new Promise((resolve, reject) => {
      this.pendingTasks.set(taskId, {
        resolve,
        reject,
        createdAt: Date.now()
      });

      // å¯»æ‰¾å¯ç”¨ Worker
      const availableIndex = this.workerAvailability.findIndex(a => a);

      if (availableIndex >= 0) {
        this.executeTask(availableIndex, task);
      } else {
        // é˜Ÿåˆ—å·²æ»¡ï¼ŒåŠ å…¥ç­‰å¾…é˜Ÿåˆ—
        this.taskQueue.push(task);
      }
    });
  }

  private executeTask(workerIndex: number, task: Task) {
    this.workerAvailability[workerIndex] = false;
    this.workers[workerIndex].postMessage(task);
  }

  private handleWorkerMessage(workerIndex: number, message: any) {
    const { taskId, result, error, success } = message;

    // é‡Šæ”¾ Worker
    this.workerAvailability[workerIndex] = true;

    // å¤„ç†ä»»åŠ¡ç»“æœ
    const pending = this.pendingTasks.get(taskId);
    if (pending) {
      if (success) {
        pending.resolve(result);
      } else {
        pending.reject(new Error(error));
      }
      this.pendingTasks.delete(taskId);
    }

    // å¤„ç†é˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªä»»åŠ¡
    if (this.taskQueue.length > 0) {
      const nextTask = this.taskQueue.shift()!;
      this.executeTask(workerIndex, nextTask);
    }
  }

  private cleanupTimeoutTasks() {
    const now = Date.now();
    const timeout = 60000; // 60 ç§’è¶…æ—¶

    for (const [taskId, pending] of this.pendingTasks.entries()) {
      if (now - pending.createdAt > timeout) {
        pending.reject(new Error('Task timeout'));
        this.pendingTasks.delete(taskId);
      }
    }
  }

  getStats() {
    return {
      workerCount: this.workers.length,
      availableWorkers: this.workerAvailability.filter(a => a).length,
      queueDepth: this.taskQueue.length,
      pendingTasks: this.pendingTasks.size
    };
  }
}
```

### 5.2 Parse Worker

```typescript
// src/workers/parse-worker.ts

import { parseDeviceData } from '../services/parse-helpers';
import { checkAlarm } from '../services/alarm-helpers';

self.onmessage = async (event) => {
  const { taskId, type, data } = event.data;

  try {
    let result;

    switch (type) {
      case 'PARSE_DEVICE_DATA':
        result = await parseDeviceData(data);
        break;

      case 'CHECK_ALARM':
        result = await checkAlarm(data);
        break;

      default:
        throw new Error(`Unknown task type: ${type}`);
    }

    self.postMessage({
      taskId,
      result,
      success: true
    });

  } catch (error: any) {
    self.postMessage({
      taskId,
      error: error.message,
      success: false
    });
  }
};
```

---

## 6. æ‰¹é‡å†™å…¥ç³»ç»Ÿ

### 6.1 æ—¥å¿—æ‰¹é‡ç¼“å†²å™¨

```typescript
// src/services/log-buffer.service.ts

import { MongoClient } from 'mongodb';

interface LogEntry {
  collection: string;
  data: any;
  timestamp: number;
}

export class LogBufferService {
  private buffer: LogEntry[] = [];
  private maxSize: number;
  private flushInterval: number;
  private flushTimer: Timer;
  private isFlushingFlag = false;

  constructor(
    private mongoClient: MongoClient,
    options: { maxSize?: number; flushInterval?: number } = {}
  ) {
    this.maxSize = options.maxSize || 1000;
    this.flushInterval = options.flushInterval || 1000;

    this.flushTimer = setInterval(() => this.flush(), this.flushInterval);
  }

  add(collection: string, data: any) {
    this.buffer.push({
      collection,
      data,
      timestamp: Date.now()
    });

    if (this.buffer.length >= this.maxSize) {
      this.flush();
    }
  }

  async flush() {
    if (this.isFlushingFlag || this.buffer.length === 0) return;

    this.isFlushingFlag = true;

    try {
      const batch = this.buffer.splice(0);

      // æŒ‰ collection åˆ†ç»„
      const grouped = new Map<string, any[]>();
      for (const entry of batch) {
        if (!grouped.has(entry.collection)) {
          grouped.set(entry.collection, []);
        }
        grouped.get(entry.collection)!.push(entry.data);
      }

      // å¹¶å‘æ‰¹é‡å†™å…¥
      await Promise.all(
        Array.from(grouped.entries()).map(([collection, docs]) =>
          this.mongoClient
            .db()
            .collection(collection)
            .insertMany(docs, { ordered: false })
            .catch(err => {
              console.error(`[LogBuffer] Failed to insert into ${collection}:`, err);
            })
        )
      );

      console.log(`[LogBuffer] Flushed ${batch.length} entries to ${grouped.size} collections`);
    } finally {
      this.isFlushingFlag = false;
    }
  }

  getStats() {
    return {
      bufferSize: this.buffer.length,
      maxSize: this.maxSize,
      isFlushing: this.isFlushingFlag
    };
  }

  async destroy() {
    clearInterval(this.flushTimer);
    await this.flush();
  }
}
```

### 6.2 çŠ¶æ€æ›´æ–°æ‰¹é‡ç¼“å†²å™¨

```typescript
// src/services/state-update-buffer.ts

import { Model } from 'mongoose';

interface StateUpdate {
  mac: string;
  pid: number;
  state: any;
  timestamp: number;
}

export class StateUpdateBuffer {
  private buffer = new Map<string, StateUpdate>();
  private flushInterval: number;
  private flushTimer: Timer;

  constructor(
    private terminalModel: Model<any>,
    options: { flushInterval?: number } = {}
  ) {
    this.flushInterval = options.flushInterval || 500;
    this.flushTimer = setInterval(() => this.flush(), this.flushInterval);
  }

  add(mac: string, pid: number, state: any = {}) {
    const key = `${mac}:${pid}`;
    this.buffer.set(key, {
      mac,
      pid,
      state,
      timestamp: Date.now()
    });
  }

  async flush() {
    if (this.buffer.size === 0) return;

    const updates = Array.from(this.buffer.values());
    this.buffer.clear();

    try {
      // ä½¿ç”¨ bulkWrite æ‰¹é‡æ›´æ–°
      const operations = updates.map(({ mac, pid, state }) => ({
        updateOne: {
          filter: { DevMac: mac, 'mountDevs.pid': pid },
          update: {
            $set: {
              'mountDevs.$.lastRecord': state.timestamp || new Date()
            }
          }
        }
      }));

      await this.terminalModel.bulkWrite(operations, { ordered: false });

      console.log(`[StateBuffer] Flushed ${updates.length} state updates`);
    } catch (error) {
      console.error('[StateBuffer] Flush failed:', error);
    }
  }

  getStats() {
    return {
      bufferSize: this.buffer.size
    };
  }

  async destroy() {
    clearInterval(this.flushTimer);
    await this.flush();
  }
}
```

---

## 7. åº”ç”¨å…¥å£

### 7.1 Main Server

```typescript
// src/server.ts

import Fastify from 'fastify';
import cors from '@fastify/cors';
import jwt from '@fastify/jwt';
import { ServiceContainer } from './core/service-container';
import { RouteLoader } from './core/route-loader';
import { connectMongoDB, createRedisClient } from './config/database';
import { WorkerPool } from './workers/worker-pool';
import { LogBufferService } from './services/log-buffer.service';
import { StateUpdateBuffer } from './services/state-update-buffer';

// Controllers
import { AuthController } from './controllers/auth.controller';
import { NodeController } from './controllers/node.controller';
// ... å…¶ä»–æ§åˆ¶å™¨

async function bootstrap() {
  // 1. åˆ›å»º Fastify åº”ç”¨
  const app = Fastify({
    logger: {
      level: process.env.LOG_LEVEL || 'info'
    }
  });

  // 2. æ³¨å†Œæ’ä»¶
  await app.register(cors, { origin: '*' });
  await app.register(jwt, {
    secret: process.env.JWT_SECRET || 'your-secret-key'
  });

  // 3. è¿æ¥æ•°æ®åº“
  const { mongoClient } = await connectMongoDB();
  const redisClient = createRedisClient();

  // 4. åˆå§‹åŒ–æœåŠ¡
  const services = new ServiceContainer();

  // Worker æ± 
  const workerPool = new WorkerPool(parseInt(process.env.WORKER_COUNT || '4'));
  services.register('WorkerPool', workerPool);

  // æ‰¹é‡å†™å…¥æœåŠ¡
  const logBuffer = new LogBufferService(mongoClient, {
    maxSize: parseInt(process.env.LOG_BUFFER_SIZE || '1000'),
    flushInterval: parseInt(process.env.LOG_FLUSH_INTERVAL || '1000')
  });
  services.register('LogBufferService', logBuffer);

  const stateBuffer = new StateUpdateBuffer(terminalModel, {
    flushInterval: parseInt(process.env.STATE_FLUSH_INTERVAL || '500')
  });
  services.register('StateUpdateBuffer', stateBuffer);

  // å…¶ä»–æœåŠ¡...
  // services.register('TerminalService', new TerminalService(...));
  // services.register('UserService', new UserService(...));
  // ...

  // 5. åŠ è½½è·¯ç”±
  const routeLoader = new RouteLoader(app, services);
  routeLoader.loadControllers([
    AuthController,
    NodeController,
    // ... å…¶ä»–æ§åˆ¶å™¨
  ]);

  // 6. å…¨å±€é”™è¯¯å¤„ç†
  app.setErrorHandler((error, request, reply) => {
    console.error('[Error]', error);
    reply.status(error.statusCode || 500).send({
      code: 0,
      status: error.statusCode || 500,
      message: error.message
    });
  });

  // 7. å¯åŠ¨æœåŠ¡å™¨
  const port = parseInt(process.env.PORT || '9001');
  const host = process.env.HOST || '0.0.0.0';

  await app.listen({ port, host });
  console.log(`ğŸš€ Server listening on http://${host}:${port}`);
  console.log(`ğŸ“Š Worker Pool: ${workerPool.getStats().workerCount} workers`);
  console.log(`ğŸ’¾ Log Buffer: max ${logBuffer.getStats().maxSize} entries`);
}

bootstrap().catch(console.error);
```

---

## 8. ç¤ºä¾‹æ§åˆ¶å™¨å®Œæ•´å®ç°

### 8.1 AuthController

```typescript
// src/controllers/auth.controller.ts

import { Controller, Post, Get, Body, User, Role, Validate } from '../decorators';
import { RoleType } from '../decorators/auth.decorator';
import Joi from 'joi';

const loginSchema = Joi.object({
  user: Joi.string().min(3).max(20).required(),
  passwd: Joi.string().min(6).required()
});

@Controller('/api/auth')
export class AuthController {
  private userService: any;
  private jwtService: any;

  constructor(private services: any) {
    this.userService = services.get('UserService');
    this.jwtService = services.get('JWTService');
  }

  @Post('/login')
  @Validate(loginSchema)
  async login(@Body() body: { user: string; passwd: string }) {
    // 1. éªŒè¯ç”¨æˆ·
    const user = await this.userService.findByUsername(body.user);
    if (!user) {
      throw { statusCode: 401, message: 'User not found' };
    }

    // 2. éªŒè¯å¯†ç 
    const isValid = await this.userService.verifyPassword(body.passwd, user.password);
    if (!isValid) {
      throw { statusCode: 401, message: 'Invalid password' };
    }

    // 3. ç”Ÿæˆ JWT Token
    const token = await this.jwtService.sign({
      user: user.user,
      userGroup: user.userGroup
    });

    // 4. è®°å½•ç™»å½•æ—¥å¿—
    await this.userService.logLogin(user.user);

    return { token, user: { user: user.user, userGroup: user.userGroup } };
  }

  @Get('/userInfo')
  @Role(RoleType.USER, RoleType.ADMIN, RoleType.ROOT)
  async userInfo(@User() user: any) {
    const userInfo = await this.userService.getUserInfo(user.user);
    return userInfo;
  }
}
```

---

## 9. æ€§èƒ½æµ‹è¯•è„šæœ¬

### 9.1 K6 è´Ÿè½½æµ‹è¯•

```javascript
// tests/performance/load-test.js

import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  stages: [
    { duration: '30s', target: 100 },   // Ramp up to 100 users
    { duration: '1m', target: 100 },    // Stay at 100 users
    { duration: '30s', target: 500 },   // Ramp up to 500 users
    { duration: '2m', target: 500 },    // Stay at 500 users
    { duration: '30s', target: 0 }      // Ramp down
  ],
  thresholds: {
    http_req_duration: ['p(95)<10'],    // 95% of requests < 10ms
    http_req_failed: ['rate<0.01']      // Error rate < 1%
  }
};

export default function () {
  const url = 'http://localhost:9001/api/node/queryData';
  const payload = JSON.stringify({
    data: {
      mac: '048070042351',
      pid: 1001,
      protocol: 'apc',
      content: [],
      timeStamp: Date.now(),
      useBytes: 128,
      useTime: 50,
      Interval: 10000
    }
  });

  const params = {
    headers: { 'Content-Type': 'application/json' }
  };

  const res = http.post(url, payload, params);

  check(res, {
    'status is 200': (r) => r.status === 200,
    'response time < 10ms': (r) => r.timings.duration < 10
  });

  sleep(0.1);  // 100ms between requests
}
```

---

## 10. ä½¿ç”¨ç¤ºä¾‹æ€»ç»“

### 10.1 åˆ›å»ºæ–°æ§åˆ¶å™¨

```typescript
import { Controller, Get, Post, Body, Query, User, Role } from '../decorators';
import { RoleType } from '../decorators/auth.decorator';

@Controller('/api/devices')
export class DeviceController {
  constructor(private services: ServiceContainer) {}

  @Get('/list')
  @Role(RoleType.USER)
  async listDevices(@User() user: any, @Query('page') page: number = 1) {
    const deviceService = this.services.get('DeviceService');
    return deviceService.list(user.user, page);
  }

  @Post('/create')
  @Role(RoleType.ADMIN)
  async createDevice(@Body() body: { name: string; type: string }) {
    const deviceService = this.services.get('DeviceService');
    return deviceService.create(body);
  }
}
```

### 10.2 Worker ä»»åŠ¡åˆ†å‘

```typescript
// åœ¨æœåŠ¡ä¸­ä½¿ç”¨ Worker æ± 
const workerPool = this.services.get('WorkerPool');

const result = await workerPool.dispatch({
  type: 'PARSE_DEVICE_DATA',
  data: queryResult
});
```

### 10.3 æ‰¹é‡æ—¥å¿—å†™å…¥

```typescript
const logBuffer = this.services.get('LogBufferService');

// æ·»åŠ æ—¥å¿—ï¼ˆç«‹å³è¿”å›ï¼‰
logBuffer.add('log_terminal', {
  mac: '048070042351',
  event: 'connect',
  timestamp: Date.now()
});
```

---

**æ–‡æ¡£çŠ¶æ€**: å¾…å®¡æ ¸
**ä¸‹ä¸€æ­¥**: æ ¹æ®å®é™…éœ€æ±‚è°ƒæ•´ä»£ç ç¤ºä¾‹
