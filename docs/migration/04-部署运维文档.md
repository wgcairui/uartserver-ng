# 部署运维文档

## 1. 环境要求

### 1.1 运行时环境

**Bun 运行时**
```bash
# 最低版本要求
Bun >= 1.1.40

# 推荐版本
Bun 1.1.40+

# 安装 Bun
curl -fsSL https://bun.sh/install | bash

# 验证安装
bun --version
```

**操作系统要求**
- Linux: Ubuntu 20.04+ / Debian 11+ / CentOS 8+
- macOS: 12.0+ (开发环境)
- Docker: 20.10+ (推荐生产部署)

**硬件要求**

| 环境 | CPU | 内存 | 磁盘 | 网络 |
|------|-----|------|------|------|
| 开发环境 | 2 核 | 4GB | 20GB | 10Mbps |
| 测试环境 | 4 核 | 8GB | 50GB | 100Mbps |
| 生产环境 | 8 核 | 16GB | 200GB SSD | 1Gbps |

### 1.2 依赖服务

**MongoDB 8.0+**
```yaml
# 最低配置
version: 8.0
replicaSet: true (生产环境必须)
storage.wiredTiger.engineConfig.cacheSizeGB: 4GB

# 推荐配置
storage.wiredTiger.engineConfig.cacheSizeGB: 8GB
storage.wiredTiger.collectionConfig.blockCompressor: snappy
net.maxIncomingConnections: 1000
```

**Redis 7.0+**
```yaml
# 最低配置
version: 7.0
maxmemory: 2GB
maxmemory-policy: allkeys-lru

# 推荐配置
maxmemory: 4GB
maxmemory-policy: allkeys-lru
timeout: 300
tcp-keepalive: 60
```

**Nginx 1.20+** (可选，用于反向代理)
```nginx
# 推荐配置
worker_processes: auto
worker_connections: 4096
keepalive_timeout: 65
```

## 2. 项目结构

### 2.1 目录结构

```
midwayuartserver-bun/
├── src/                          # 源代码
│   ├── controllers/              # 控制器
│   ├── services/                 # 服务层
│   ├── models/                   # 数据模型
│   ├── decorators/               # 装饰器
│   ├── middlewares/              # 中间件
│   ├── workers/                  # Worker 线程
│   ├── utils/                    # 工具函数
│   ├── types/                    # 类型定义
│   └── app.ts                    # 应用入口
├── config/                       # 配置文件
│   ├── development.ts
│   ├── production.ts
│   └── test.ts
├── logs/                         # 日志目录
├── data/                         # 数据目录
│   └── queue.db                  # SQLite 队列数据库
├── tests/                        # 测试代码
├── scripts/                      # 部署脚本
│   ├── start.sh
│   ├── stop.sh
│   └── health-check.sh
├── docker/                       # Docker 配置
│   ├── Dockerfile
│   ├── docker-compose.yml
│   └── nginx.conf
├── .env.example                  # 环境变量模板
├── package.json
├── tsconfig.json
└── README.md
```

### 2.2 配置文件说明

**package.json**
```json
{
  "name": "midwayuartserver-bun",
  "version": "2.0.0",
  "type": "module",
  "scripts": {
    "dev": "bun run --watch src/app.ts",
    "build": "bun build src/app.ts --outdir dist --target bun",
    "start": "bun run dist/app.js",
    "test": "bun test",
    "lint": "eslint src --ext .ts",
    "format": "prettier --write 'src/**/*.ts'"
  }
}
```

**.env 配置**
```bash
# 服务配置
NODE_ENV=production
PORT=9000
HOST=0.0.0.0

# MongoDB 配置
MONGODB_URI=mongodb://localhost:27017/uart_server
MONGODB_MAX_POOL_SIZE=100
MONGODB_MIN_POOL_SIZE=10

# Redis 配置
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=
REDIS_DB=0

# Worker 配置
WORKER_POOL_SIZE=8
WORKER_MAX_QUEUE_SIZE=10000

# 日志配置
LOG_LEVEL=info
LOG_DIR=./logs

# 性能配置
BATCH_WRITE_MAX_SIZE=1000
BATCH_WRITE_FLUSH_INTERVAL=1000
STATE_UPDATE_BUFFER_INTERVAL=500

# 外部服务配置（保持原有配置）
ALIOSS_ID=
ALIOSS_SECRET=
ALIOSS_BUCKET=
ALIOSS_ENDPOINT=

TENCETMAP_KEY=
TENCETMAP_URL=
TENCETMAP_SK=

# 微信配置
WX_PUBLIC_APPID=
WX_PUBLIC_SECRET=
WX_OPEN_APPID=
WX_OPEN_SECRET=

# 短信配置
SMS_ACCESSKEY_ID=
SMS_ACCESSKEY_SECRET=
SMS_SIGN_NAME=

# 邮件配置
MAIL_HOST=
MAIL_PORT=
MAIL_USER=
MAIL_PASS=
```

## 3. 部署方式

### 3.1 Docker 部署（推荐）

**Dockerfile**
```dockerfile
# 阶段 1: 构建
FROM oven/bun:1.1.40 AS builder

WORKDIR /app

# 复制依赖文件
COPY package.json bun.lockb ./

# 安装依赖
RUN bun install --frozen-lockfile

# 复制源代码
COPY . .

# 构建项目
RUN bun build src/app.ts --outdir dist --target bun

# 阶段 2: 运行
FROM oven/bun:1.1.40-slim

WORKDIR /app

# 复制构建产物
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./

# 创建日志和数据目录
RUN mkdir -p logs data

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=40s --retries=3 \
  CMD bun run scripts/health-check.ts || exit 1

# 暴露端口
EXPOSE 9000

# 启动应用
CMD ["bun", "run", "dist/app.js"]
```

**docker-compose.yml**
```yaml
version: '3.8'

services:
  # 主应用
  app:
    build:
      context: .
      dockerfile: docker/Dockerfile
    container_name: uart-server
    restart: unless-stopped
    ports:
      - "9000:9000"
    environment:
      NODE_ENV: production
      MONGODB_URI: mongodb://mongo:27017/uart_server
      REDIS_HOST: redis
      REDIS_PORT: 6379
    volumes:
      - ./logs:/app/logs
      - ./data:/app/data
    depends_on:
      - mongo
      - redis
    networks:
      - uart-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/health"]
      interval: 30s
      timeout: 3s
      retries: 3
      start_period: 40s

  # MongoDB
  mongo:
    image: mongo:8.0
    container_name: uart-mongo
    restart: unless-stopped
    ports:
      - "27017:27017"
    environment:
      MONGO_INITDB_ROOT_USERNAME: admin
      MONGO_INITDB_ROOT_PASSWORD: your_password
      MONGO_INITDB_DATABASE: uart_server
    volumes:
      - mongo-data:/data/db
      - ./docker/mongo-init.js:/docker-entrypoint-initdb.d/init.js:ro
    command: mongod --replSet rs0 --bind_ip_all
    networks:
      - uart-network

  # Redis
  redis:
    image: redis:7.4-alpine
    container_name: uart-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    command: redis-server --appendonly yes --maxmemory 4gb --maxmemory-policy allkeys-lru
    networks:
      - uart-network

  # Nginx 反向代理（可选）
  nginx:
    image: nginx:1.25-alpine
    container_name: uart-nginx
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./docker/nginx.conf:/etc/nginx/nginx.conf:ro
      - ./docker/ssl:/etc/nginx/ssl:ro
    depends_on:
      - app
    networks:
      - uart-network

volumes:
  mongo-data:
  redis-data:

networks:
  uart-network:
    driver: bridge
```

**部署命令**
```bash
# 1. 克隆项目
git clone <repository-url>
cd midwayuartserver-bun

# 2. 配置环境变量
cp .env.example .env
# 编辑 .env 文件，填入实际配置

# 3. 构建并启动服务
docker-compose up -d

# 4. 查看日志
docker-compose logs -f app

# 5. 检查服务状态
docker-compose ps

# 6. 健康检查
curl http://localhost:9000/health
```

### 3.2 传统部署

**安装依赖**
```bash
# 1. 安装 Bun
curl -fsSL https://bun.sh/install | bash

# 2. 克隆项目
git clone <repository-url>
cd midwayuartserver-bun

# 3. 安装依赖
bun install

# 4. 配置环境变量
cp .env.example .env
# 编辑 .env 文件

# 5. 构建项目
bun run build

# 6. 启动服务
bun run start
```

**使用 PM2 管理进程**
```bash
# 安装 PM2
bun add -g pm2

# PM2 配置文件 ecosystem.config.js
module.exports = {
  apps: [{
    name: 'uart-server',
    script: './dist/app.js',
    interpreter: 'bun',
    instances: 1, // 不要使用 cluster 模式，Bun 已经多线程优化
    exec_mode: 'fork',
    env: {
      NODE_ENV: 'production',
      PORT: 9000
    },
    error_file: './logs/pm2-error.log',
    out_file: './logs/pm2-out.log',
    log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
    max_memory_restart: '1G',
    autorestart: true,
    watch: false
  }]
};

# 启动服务
pm2 start ecosystem.config.js

# 查看状态
pm2 status

# 查看日志
pm2 logs uart-server

# 重启服务
pm2 restart uart-server

# 停止服务
pm2 stop uart-server

# 开机自启
pm2 startup
pm2 save
```

### 3.3 Kubernetes 部署

**deployment.yaml**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: uart-server
  namespace: iot
spec:
  replicas: 3
  selector:
    matchLabels:
      app: uart-server
  template:
    metadata:
      labels:
        app: uart-server
    spec:
      containers:
      - name: uart-server
        image: your-registry/uart-server:2.0.0
        ports:
        - containerPort: 9000
          name: http
        env:
        - name: NODE_ENV
          value: "production"
        - name: MONGODB_URI
          valueFrom:
            secretKeyRef:
              name: uart-secrets
              key: mongodb-uri
        - name: REDIS_HOST
          value: "redis-service"
        resources:
          requests:
            cpu: "2"
            memory: "4Gi"
          limits:
            cpu: "4"
            memory: "8Gi"
        livenessProbe:
          httpGet:
            path: /health
            port: 9000
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 3
        readinessProbe:
          httpGet:
            path: /health
            port: 9000
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
        volumeMounts:
        - name: logs
          mountPath: /app/logs
        - name: data
          mountPath: /app/data
      volumes:
      - name: logs
        emptyDir: {}
      - name: data
        persistentVolumeClaim:
          claimName: uart-data-pvc

---
apiVersion: v1
kind: Service
metadata:
  name: uart-server-service
  namespace: iot
spec:
  type: LoadBalancer
  selector:
    app: uart-server
  ports:
  - protocol: TCP
    port: 80
    targetPort: 9000
    name: http
```

## 4. 灰度发布策略

### 4.1 Nginx 灰度配置

```nginx
upstream uart_old {
    server 192.168.1.10:9000 weight=9;  # 旧版本 90% 流量
}

upstream uart_new {
    server 192.168.1.20:9000 weight=1;  # 新版本 10% 流量
}

upstream uart_backend {
    server 192.168.1.10:9000 weight=9;
    server 192.168.1.20:9000 weight=1;
}

server {
    listen 80;
    server_name api.example.com;

    location / {
        # 灰度策略：基于 Cookie
        set $backend "uart_old";

        if ($http_cookie ~* "gray_version=new") {
            set $backend "uart_new";
        }

        # 灰度策略：基于 IP 段
        if ($remote_addr ~* "^10\.0\.1\.") {
            set $backend "uart_new";
        }

        proxy_pass http://$backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        # WebSocket 支持
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";

        # 超时配置
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    # 健康检查端点
    location /health {
        access_log off;
        proxy_pass http://uart_backend;
    }
}
```

### 4.2 灰度发布流程

**阶段 1: 小流量验证（5%）**
```bash
# 1. 部署新版本到灰度环境
docker-compose -f docker-compose.gray.yml up -d

# 2. 配置 Nginx 灰度权重 (5%)
upstream uart_backend {
    server old-server:9000 weight=19;  # 95%
    server new-server:9000 weight=1;   # 5%
}

# 3. 重载 Nginx 配置
nginx -s reload

# 4. 监控关键指标（持续 1 小时）
- HTTP 请求成功率 > 99.9%
- queryData API P95 延迟 < 10ms
- 错误日志无异常
- CPU 使用率 < 50%
- 内存使用 < 500MB

# 5. 验证通过，进入下一阶段
```

**阶段 2: 中等流量（30%）**
```bash
# 1. 调整权重 (30%)
upstream uart_backend {
    server old-server:9000 weight=7;   # 70%
    server new-server:9000 weight=3;   # 30%
}

# 2. 重载配置
nginx -s reload

# 3. 监控（持续 2 小时）
- 对比新旧版本性能指标
- 检查数据一致性
- 验证 Socket.IO 连接稳定性

# 4. 验证通过，进入下一阶段
```

**阶段 3: 全量发布（100%）**
```bash
# 1. 调整权重 (100%)
upstream uart_backend {
    server new-server:9000;  # 100%
}

# 2. 重载配置
nginx -s reload

# 3. 监控（持续 24 小时）
- 全面性能指标监控
- 业务数据准确性验证

# 4. 下线旧版本
docker-compose -f docker-compose.old.yml down
```

## 5. 监控和日志

### 5.1 日志配置

**Pino 日志配置**
```typescript
// src/utils/logger.ts
import pino from 'pino';

export const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  transport: {
    targets: [
      {
        target: 'pino-pretty',
        level: 'info',
        options: {
          colorize: true,
          translateTime: 'SYS:standard',
          ignore: 'pid,hostname',
        },
      },
      {
        target: 'pino/file',
        level: 'info',
        options: {
          destination: `${process.env.LOG_DIR || './logs'}/app.log`,
          mkdir: true,
        },
      },
      {
        target: 'pino/file',
        level: 'error',
        options: {
          destination: `${process.env.LOG_DIR || './logs'}/error.log`,
          mkdir: true,
        },
      },
    ],
  },
});
```

**日志分类**
```
logs/
├── app.log           # 应用日志
├── error.log         # 错误日志
├── access.log        # 访问日志
├── query.log         # 查询日志（queryData API）
├── socket.log        # Socket.IO 日志
└── worker.log        # Worker 日志
```

### 5.2 性能监控

**Prometheus 指标采集**
```typescript
// src/utils/metrics.ts
import client from 'prom-client';

// 创建 Registry
export const register = new client.Registry();

// 默认指标（CPU、内存、事件循环延迟）
client.collectDefaultMetrics({ register });

// 自定义指标
export const httpRequestDuration = new client.Histogram({
  name: 'http_request_duration_ms',
  help: 'HTTP request duration in milliseconds',
  labelNames: ['method', 'route', 'status_code'],
  buckets: [1, 5, 10, 25, 50, 100, 250, 500, 1000],
  registers: [register],
});

export const queryDataCounter = new client.Counter({
  name: 'query_data_total',
  help: 'Total number of queryData API calls',
  labelNames: ['status'],
  registers: [register],
});

export const workerPoolQueueSize = new client.Gauge({
  name: 'worker_pool_queue_size',
  help: 'Current worker pool queue size',
  registers: [register],
});

export const mongodbBatchWriteSize = new client.Histogram({
  name: 'mongodb_batch_write_size',
  help: 'MongoDB batch write size',
  buckets: [10, 50, 100, 200, 500, 1000],
  registers: [register],
});

// 暴露 metrics 端点
app.get('/metrics', async (req, res) => {
  res.setHeader('Content-Type', register.contentType);
  res.send(await register.metrics());
});
```

**Grafana 仪表板配置**
```json
{
  "dashboard": {
    "title": "UART Server Monitoring",
    "panels": [
      {
        "title": "HTTP Request Duration (P50/P95/P99)",
        "targets": [
          {
            "expr": "histogram_quantile(0.5, rate(http_request_duration_ms_bucket[5m]))",
            "legendFormat": "P50"
          },
          {
            "expr": "histogram_quantile(0.95, rate(http_request_duration_ms_bucket[5m]))",
            "legendFormat": "P95"
          },
          {
            "expr": "histogram_quantile(0.99, rate(http_request_duration_ms_bucket[5m]))",
            "legendFormat": "P99"
          }
        ]
      },
      {
        "title": "queryData API QPS",
        "targets": [
          {
            "expr": "rate(query_data_total[1m])",
            "legendFormat": "QPS"
          }
        ]
      },
      {
        "title": "Worker Pool Queue Size",
        "targets": [
          {
            "expr": "worker_pool_queue_size",
            "legendFormat": "Queue Size"
          }
        ]
      },
      {
        "title": "MongoDB Batch Write Size",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(mongodb_batch_write_size_bucket[5m]))",
            "legendFormat": "P95 Batch Size"
          }
        ]
      }
    ]
  }
}
```

### 5.3 告警规则

**Prometheus 告警配置**
```yaml
# prometheus-alerts.yml
groups:
- name: uart_server_alerts
  interval: 30s
  rules:
  # HTTP 请求延迟告警
  - alert: HighHTTPLatency
    expr: histogram_quantile(0.95, rate(http_request_duration_ms_bucket[5m])) > 50
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "HTTP P95 latency is high"
      description: "HTTP P95 latency is {{ $value }}ms (threshold: 50ms)"

  # queryData API 成功率告警
  - alert: LowQueryDataSuccessRate
    expr: rate(query_data_total{status="success"}[5m]) / rate(query_data_total[5m]) < 0.999
    for: 5m
    labels:
      severity: critical
    annotations:
      summary: "queryData API success rate is low"
      description: "Success rate is {{ $value | humanizePercentage }} (threshold: 99.9%)"

  # Worker 队列积压告警
  - alert: HighWorkerQueueSize
    expr: worker_pool_queue_size > 5000
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "Worker pool queue size is high"
      description: "Queue size is {{ $value }} (threshold: 5000)"

  # CPU 使用率告警
  - alert: HighCPUUsage
    expr: process_cpu_seconds_total > 0.7
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "CPU usage is high"
      description: "CPU usage is {{ $value | humanizePercentage }}"

  # 内存使用告警
  - alert: HighMemoryUsage
    expr: process_resident_memory_bytes > 800 * 1024 * 1024
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "Memory usage is high"
      description: "Memory usage is {{ $value | humanizeBytes }}"
```

## 6. 备份和恢复

### 6.1 MongoDB 备份

**自动备份脚本**
```bash
#!/bin/bash
# scripts/backup-mongodb.sh

# 配置
BACKUP_DIR="/data/backups/mongodb"
DATE=$(date +%Y%m%d_%H%M%S)
MONGODB_URI="mongodb://admin:password@localhost:27017"
DATABASE="uart_server"
RETENTION_DAYS=7

# 创建备份目录
mkdir -p $BACKUP_DIR

# 执行备份
mongodump --uri="$MONGODB_URI" --db=$DATABASE --out=$BACKUP_DIR/$DATE

# 压缩备份
tar -czf $BACKUP_DIR/$DATE.tar.gz -C $BACKUP_DIR $DATE
rm -rf $BACKUP_DIR/$DATE

# 删除旧备份
find $BACKUP_DIR -name "*.tar.gz" -mtime +$RETENTION_DAYS -delete

echo "Backup completed: $BACKUP_DIR/$DATE.tar.gz"
```

**设置定时备份**
```bash
# 添加到 crontab
crontab -e

# 每天凌晨 2 点执行备份
0 2 * * * /opt/scripts/backup-mongodb.sh >> /var/log/mongodb-backup.log 2>&1
```

**恢复备份**
```bash
#!/bin/bash
# scripts/restore-mongodb.sh

BACKUP_FILE=$1
MONGODB_URI="mongodb://admin:password@localhost:27017"
DATABASE="uart_server"

if [ -z "$BACKUP_FILE" ]; then
  echo "Usage: $0 <backup_file.tar.gz>"
  exit 1
fi

# 解压备份
TEMP_DIR=$(mktemp -d)
tar -xzf $BACKUP_FILE -C $TEMP_DIR

# 恢复数据
mongorestore --uri="$MONGODB_URI" --db=$DATABASE --drop $TEMP_DIR/*

# 清理临时文件
rm -rf $TEMP_DIR

echo "Restore completed from: $BACKUP_FILE"
```

### 6.2 SQLite 队列数据库备份

```bash
#!/bin/bash
# scripts/backup-sqlite.sh

QUEUE_DB="/app/data/queue.db"
BACKUP_DIR="/data/backups/sqlite"
DATE=$(date +%Y%m%d_%H%M%S)

mkdir -p $BACKUP_DIR

# 使用 SQLite backup API
sqlite3 $QUEUE_DB ".backup $BACKUP_DIR/queue_$DATE.db"

# 压缩
gzip $BACKUP_DIR/queue_$DATE.db

# 删除 7 天前的备份
find $BACKUP_DIR -name "queue_*.db.gz" -mtime +7 -delete

echo "SQLite backup completed: $BACKUP_DIR/queue_$DATE.db.gz"
```

## 7. 故障恢复

### 7.1 服务崩溃恢复

**自动重启（PM2）**
```bash
# PM2 自动重启配置
pm2 start ecosystem.config.js

# PM2 会自动监控进程，崩溃后自动重启
# 查看重启历史
pm2 show uart-server
```

**手动重启**
```bash
# Docker
docker-compose restart app

# 传统部署
systemctl restart uart-server
```

### 7.2 数据库故障恢复

**MongoDB 主节点故障**
```bash
# 1. 检查副本集状态
mongosh --eval "rs.status()"

# 2. 如果主节点不可用，副本集会自动选举新主节点
# 应用会自动重连到新主节点（使用 replicaSet 连接字符串）

# 3. 修复故障节点
docker-compose restart mongo

# 4. 重新加入副本集
mongosh --eval "rs.add('mongo2:27017')"
```

**Redis 故障**
```bash
# 1. 检查 Redis 状态
redis-cli ping

# 2. 重启 Redis
docker-compose restart redis

# 3. 应用会自动重连（使用 ioredis 重连机制）
```

### 7.3 回滚策略

**快速回滚**
```bash
# 1. 停止新版本
docker-compose down

# 2. 切换到旧版本
git checkout v1.x.x

# 3. 启动旧版本
docker-compose up -d

# 4. 验证服务
curl http://localhost:9000/health

# 5. 更新 Nginx 配置（如果使用灰度发布）
# 将所有流量切回旧版本
upstream uart_backend {
    server old-server:9000;
}
nginx -s reload
```

## 8. 健康检查

### 8.1 健康检查端点

```typescript
// src/routes/health.ts
import { FastifyInstance } from 'fastify';
import { MongoClient } from 'mongodb';
import { RedisClient } from '../utils/redis';

export async function healthRoutes(app: FastifyInstance) {
  // 基本健康检查
  app.get('/health', async (req, res) => {
    return { status: 'ok', timestamp: Date.now() };
  });

  // 详细健康检查
  app.get('/health/detailed', async (req, res) => {
    const health = {
      status: 'ok',
      timestamp: Date.now(),
      uptime: process.uptime(),
      version: process.env.npm_package_version,
      memory: process.memoryUsage(),
      services: {
        mongodb: 'unknown',
        redis: 'unknown',
      },
    };

    // 检查 MongoDB
    try {
      await MongoClient.db().admin().ping();
      health.services.mongodb = 'ok';
    } catch (err) {
      health.services.mongodb = 'error';
      health.status = 'degraded';
    }

    // 检查 Redis
    try {
      await RedisClient.ping();
      health.services.redis = 'ok';
    } catch (err) {
      health.services.redis = 'error';
      health.status = 'degraded';
    }

    return health;
  });

  // 就绪检查（Kubernetes readiness probe）
  app.get('/ready', async (req, res) => {
    try {
      await MongoClient.db().admin().ping();
      await RedisClient.ping();
      return { ready: true };
    } catch (err) {
      res.status(503);
      return { ready: false, error: err.message };
    }
  });

  // 存活检查（Kubernetes liveness probe）
  app.get('/alive', async (req, res) => {
    return { alive: true };
  });
}
```

### 8.2 外部监控

**Uptime Kuma 配置**
```yaml
# docker-compose.monitoring.yml
version: '3.8'

services:
  uptime-kuma:
    image: louislam/uptime-kuma:1
    container_name: uptime-kuma
    volumes:
      - uptime-kuma-data:/app/data
    ports:
      - "3001:3001"
    restart: unless-stopped

volumes:
  uptime-kuma-data:
```

**监控配置**
- HTTP(s): GET http://api.example.com/health
- 检查间隔: 60 秒
- 超时: 10 秒
- 重试次数: 3
- 告警方式: 邮件 + 企业微信

## 9. 性能调优

### 9.1 系统参数优化

**Linux 内核参数**
```bash
# /etc/sysctl.conf

# 网络优化
net.core.somaxconn = 65535
net.ipv4.tcp_max_syn_backlog = 8192
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_fin_timeout = 30
net.ipv4.ip_local_port_range = 1024 65535

# 文件描述符
fs.file-max = 1000000
fs.nr_open = 1000000

# 应用生效
sysctl -p
```

**用户限制**
```bash
# /etc/security/limits.conf
* soft nofile 1000000
* hard nofile 1000000
* soft nproc 65535
* hard nproc 65535
```

### 9.2 MongoDB 优化

```javascript
// MongoDB 索引优化
db.uartTerminalResults.createIndex({ mac: 1, pid: 1, timeStamp: -1 });
db.uartTerminalResults.createIndex({ timeStamp: -1 }, { expireAfterSeconds: 2592000 }); // 30 天 TTL

// 连接池配置
const client = new MongoClient(uri, {
  maxPoolSize: 100,
  minPoolSize: 10,
  maxIdleTimeMS: 60000,
  serverSelectionTimeoutMS: 5000,
  socketTimeoutMS: 45000,
});

// 写关注级别
db.collection.insertMany(docs, { writeConcern: { w: 1, j: false } });
```

### 9.3 Redis 优化

```bash
# redis.conf

# 内存优化
maxmemory 4gb
maxmemory-policy allkeys-lru

# 持久化
save 900 1
save 300 10
save 60 10000
appendonly yes
appendfsync everysec

# 性能优化
tcp-backlog 511
timeout 0
tcp-keepalive 300
```

## 10. 安全加固

### 10.1 应用安全

**Helmet 中间件**
```typescript
import helmet from '@fastify/helmet';

app.register(helmet, {
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", 'data:', 'https:'],
    },
  },
});
```

**速率限制**
```typescript
import rateLimit from '@fastify/rate-limit';

app.register(rateLimit, {
  global: true,
  max: 100,
  timeWindow: '1 minute',
  cache: 10000,
  allowList: ['127.0.0.1'],
  redis: redisClient,
});

// queryData API 特殊限制
app.register(rateLimit, {
  max: 1000,
  timeWindow: '1 minute',
}, (app) => {
  app.post('/api/node/queryData', ...);
});
```

### 10.2 数据库安全

**MongoDB 用户权限**
```javascript
// 创建应用用户（只读写权限，无管理权限）
db.createUser({
  user: "uart_app",
  pwd: "strong_password",
  roles: [
    { role: "readWrite", db: "uart_server" }
  ]
});

// 连接字符串使用非 root 用户
MONGODB_URI=mongodb://uart_app:strong_password@localhost:27017/uart_server
```

**Redis 密码保护**
```bash
# redis.conf
requirepass strong_redis_password
```

### 10.3 网络安全

**防火墙配置**
```bash
# UFW 防火墙规则
ufw default deny incoming
ufw default allow outgoing
ufw allow 22/tcp     # SSH
ufw allow 80/tcp     # HTTP
ufw allow 443/tcp    # HTTPS
ufw allow from 10.0.0.0/8 to any port 9000  # 内网访问应用端口
ufw enable
```

**Nginx SSL 配置**
```nginx
server {
    listen 443 ssl http2;
    server_name api.example.com;

    ssl_certificate /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;

    # HSTS
    add_header Strict-Transport-Security "max-age=31536000" always;

    location / {
        proxy_pass http://uart_backend;
    }
}
```

## 11. 常见问题

### 11.1 服务无法启动

**问题：端口已被占用**
```bash
# 查找占用端口的进程
lsof -i :9000
# 或
netstat -tlnp | grep 9000

# 杀死进程
kill -9 <PID>
```

**问题：MongoDB 连接失败**
```bash
# 检查 MongoDB 状态
docker-compose ps mongo
# 或
systemctl status mongod

# 查看 MongoDB 日志
docker-compose logs mongo
# 或
tail -f /var/log/mongodb/mongod.log

# 检查连接字符串
echo $MONGODB_URI
```

### 11.2 性能问题

**问题：queryData API 响应慢**
```bash
# 1. 检查 Worker 队列积压
curl http://localhost:9000/metrics | grep worker_pool_queue_size

# 2. 增加 Worker 数量
export WORKER_POOL_SIZE=16
docker-compose restart app

# 3. 检查 MongoDB 慢查询
db.currentOp({ "active": true, "secs_running": { "$gt": 1 } })
```

**问题：内存使用过高**
```bash
# 1. 检查内存使用
docker stats uart-server

# 2. 调整批量写入缓冲区大小
export BATCH_WRITE_MAX_SIZE=500
export BATCH_WRITE_FLUSH_INTERVAL=500

# 3. 重启服务
docker-compose restart app
```

### 11.3 数据问题

**问题：数据丢失**
```bash
# 1. 检查 MongoDB 备份
ls -lh /data/backups/mongodb/

# 2. 恢复最近的备份
./scripts/restore-mongodb.sh /data/backups/mongodb/20240101_020000.tar.gz

# 3. 验证数据完整性
mongosh --eval "db.uartTerminalResults.countDocuments()"
```

## 12. 运维检查清单

### 12.1 日常检查（每天）

- [ ] 检查服务运行状态
- [ ] 查看错误日志
- [ ] 监控关键指标（CPU、内存、延迟）
- [ ] 检查磁盘空间
- [ ] 验证备份完成

### 12.2 周度检查（每周）

- [ ] 审查性能趋势
- [ ] 检查告警历史
- [ ] 清理旧日志文件
- [ ] 测试备份恢复流程
- [ ] 更新依赖包（安全补丁）

### 12.3 月度检查（每月）

- [ ] 容量规划评估
- [ ] 安全漏洞扫描
- [ ] 性能优化分析
- [ ] 灾难恢复演练
- [ ] 文档更新

---

**文档版本**: v1.0
**最后更新**: 2024-12-16
**维护者**: 开发团队
